# 加载

## 1. 引用类型

- 类：字节流，基本上是class文件
- 接口：字节流，基本上是class文件
- 数组类：Java虚拟机直接生成
- 泛型参数：编译过程中会被擦除

## 2. 加载

指哈找字节流，并且根据此创建类的过程。Java虚拟机需要借助类加载器来完成查找字节流的过程。

1. 祖师爷：启动类加载器，由C++实现，没有对应的Java对象，因此java中只能用null来替代。
2. 其他：都是java.lang.ClassLoader的子类，因此都有对应的Java对象。这些类加载器需要先由另一个类加载器，比方说启动类加载器，加载至Java虚拟机中，方能执行类加载。

### 2.1 双亲委派模型

每个类加载器接收到加载请求的时候，会先将请求转发给父类加载器，在父类没有找到所请求的类的情况下。该类加载器才会尝试加载。

在Java9前，启动类加载器负责加载最为基础重要的类，比如存放在JRE的lib目录下的jar包中的类。除了启动类加载器之外，其他两个重要的类夹杂器是扩展类加载器和应用类加载器，由Java核心库提供。

- 扩展类加载器的父类加载器是启动类加载器，负责加载相对次要，但又通用的类，比如放在JRE的lib/ext目录下的jar包的类（以及系统变量java.ext.dirs指定的类）
- 应用类加载器的父类加载器则是扩展类加载器。负责加载应用程序路径下的类。默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java9引入了模块，扩展类加载器被改名为平台类加载器。除了少数几个关键模块，其他都由平台类加载器所加载。

我们还可以加入自定义的类加载器，来实现特殊的加载方式。比方说对class文件加密后，加载时用自定义的类加载器对其加密。

<u>在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确认的。因此即便是同一串字节流。经由不同的类加载器加载，也会得到两个不同的类。</u>



## 3. 链接

指将创建成的类合并至Java虚拟机中，使之能够执行的过程。

### 3.1 验证

确保被加载类能够满足Java虚拟机的约束条件，类似设计审核，只有过了才能下一步。

### 3.2 准备

为被加载类的静态字段分配内存。Java中对静态字段的具体初始化是在初始化阶段中进行的。

部分Java虚拟机还会在此阶段构造其他跟类层次相关的数据结构。比如说用来实现虚方法的动态绑定的方法表。



> 在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义的定位到具体目标上（如果定义了与系统类库同名的java类，会加载到系统库的类）。

### 3.3 解析

将符号引用解析为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）

## 4. 初始化

如果直接赋值的静态字段被final所修饰，并且它的类型时基本类型或字符串时，那么该字段会被Java编译器标记为常量值。其初始化由Java虚拟机直接完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，会被Java编译器置于同一方法中，命名为<clinit>，此方法会被加锁保证仅执行一次。

成功后，类才正式成为可执行的状态。

初始化的触发场景

- 当虚拟机启动时，初始化用户指定的主类。
- 当遇到用以新建目标类实例的new命令时，初始化new指令的目标类。
- 当遇到调用静态方法的指令时，初始化该静态方法所在的类。
- 当遇到访问静态字段的指令时，初始化该静态字段所在的类。
- 子类的初始化会触发父类的初始化。
- 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化。
- 使用反射API对某个类进行反射调用时，初始化这个类。
- 初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

```shell
java -verbose:class Singleton # 查看类加载顺序
```

