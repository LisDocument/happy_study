# 垃圾回收

<u>首先说明：免费的其实是最贵的</u>

## 1. 引用计数法

为每个对象添加一个引用计数器，用来统计指向该对象的引用个数，如果是0的话，就表明对象已经死亡。

如果有一个引用，被赋值为某一个对象，那么这个对象的引用计数器+1，如果该引用被指向其他值，那么该对象的引用计数 -1， 因此我们需要截获所有引用更新操作，并且相应增减计数。

劣势：

- 需要额外的空间
- 繁琐的更新操作
- 无法处理循环引用。

## 2. 可达性分析算法

将一系列GC Roots作为初始的存活对象合集，从合集出发，探索所有能够被该集合引用到的对象，并且加入该集合中，这个过程也被称为标记。最后未被探索到的对象便是死亡的，可以回收的。

一般而言，GC Roots包括（但不限于）如下几种

- Java方法栈中的局部变量
- 已加载的静态变量
- JNI handles
- 已启动且未停止的Java线程

可达性分析可以解决引用计数法所不能解决的循环引用问题。即使a和b互相引用，但是GC Roots出发无法到达a或b，那么可达性分析便不会将他们加入存活对象合集中。

劣势：

- 在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而导致误报（引用设置为null）或者漏报（将引用设置为未被访问过的对象）。

## 3. STW以及安全点

传统的垃圾回收算法采用的是STW方案，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。

Java虚拟机中的STW是通过安全点机制来实现的，当虚拟机收到STW请求，便会等待所有线程都到安全点，才允许Stop-the-world的线程进行独占的工作。

当然，安全点的初始目的不是让其他线程停下，而是找到一个稳定的执行状态，这个状态下，Java虚拟机的堆栈不会发生变化。那么垃圾回收器就能安全执行可达性分析。

//todo 安全点的种种状态

## 4. 垃圾回收的三种方式

### 4.1 清除（sweep）

将死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新的对象。

劣势：

- 会造成内存碎片，由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况
- 分配效率低，如果是一块连续的内存空间，那么我们可以通过指针加法来坐分配，对于空闲列表，Java虚拟机需要逐个访问列表中的额项，来查找能够放入新建对象的空闲内存。

### 4.2 压缩（compact）

即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这样能够解决内存碎片化的问题，但是代价是压缩算法的性能开销。

### 4.3 复制（copy）

内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。复制这种回收方式也能够解决内存碎片化的问题。但是堆空间的使用率极其低下。

## 5. 实际实现（分代回收思想）

基于一个假设：**即大部分的Java对象只存活一小段时间，而存活下来的小部分Java对象则会存活很长一段时间。**

Java虚拟机可以给不同代使用不同的回收算法。

对于新生代，我们猜测大部分的Java对象只能存活一小段时间，那么可以频繁的采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。

对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。这时候就要进行full gc了。

### 5.1 Java虚拟机的堆划分

虚拟机被划分为新生代和老年代。其中新生代又被划分为Eden区，以及两个大小相同的Survivor区。

默认情况下，Java虚拟机采取的是一种动态分配的策略**（-XX:+UsePSAdaptiveSurvivorSizePolicy）**，根据生成对象的速率，以及Survivor区的使用情况动态调整Eden区和Survivor区的比例。

也可以通过（-XX:SurvivorRatio）来固定这个比例。但是其中一个Survivor区会一直为空，因此比例越低越浪费的堆空间越高



每当使用new命令时，会在Eden中划出一块作为存储对象的内存，由于堆空间时线程共享的，因此直接划需要进行同步。否则可能出现两个对象共用一段内存的事故。因此引入TLAB（Thread Local Allocation Buffer）**（-XX:+UserTLAB，默认开启）**，每个线程可以向Java虚拟机申请一段连续的内存，作为线程私有的TLAB。操作带锁，线程需要维护两个指针（可能更多），一个指向TLAB空余内存的起始位置，一个指向TLAB末尾。



当Eden空间耗尽了Java虚拟机会触发一下MinorGC，来收集新生代的垃圾，存活下来的被送到Survivor区。新生代存在两个Survivor区，即from和to，to的区市空的。

当发生MinorGC时，Eden区和from指向的Survivor区中的存活对象会被复制到to中，然后交换from和to指针，以此保证下一次MinorGC时，to是空的。

Java虚拟机会记录Survivor区中的对象一共被来回复制了几次。如果一个对象被复制的次数为15**（-XX:+MaxTenuringThreshold）**<u>（对象头的标记字段里记录年龄，分配的空间只有4位，最多只能到5）</u>，那么该对象会被晋升到老年代。另外如果耽搁Survivor区已经被占用了50%**（-XX:TargetSurvivorRatio）**，那么较高复制次数的对象也会被晋升。

### 5.2 扫描标记

当发生MinorGC的时候使用标记复制算法，将Survivor区中老存活的对象晋升为老年代，然后复制剩下的存活对象和Eden区的存活对象复制到to中，理想中Eden中的对象基本上都死亡了，需要复制的数据非常少，因此采用这种效果极好。

且MinorGC不用对整个堆进行垃圾回收，但是有一个问题，老年代的对象可能引用新生代的对象，那么在标记存活对象的时候，我们需要扫描老年代的对象，但是如果对象游泳对新生代的引用，那么这个也会被作为GCRoots，那不是全堆扫描？

#### 5.2.1 卡表

这个将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表。用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代的对象的引用，如果可能存在，那么就认为这个卡是脏的。

因此在MinorGC的时候，只需要在卡表寻找脏卡并且将脏卡的对象加入MinorGC的GCRoots中，完成所有的脏卡的扫描之后，Java虚拟机会将所有脏卡的标识位清零。

由于MinorGC伴随着存活对象的复制，复制需要更新指向该对象的引用，因此在更新引用的同时，又会设置所在的卡的标识位，这个时候我们可以确保脏卡中必定包含新生对象的引用。

但是在MinorGC之前，脏卡是不被保证的，因为没有进行过置卡。引入了写屏障。写屏障不会判断更新后的引用是否指向新生代的对象，是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。

但是在高并发的情况下，写屏障又带来了**虚共享**的问题（卡表是通过byte数组来实现的，对于一个64字节的缓存行来说，如果用它来加载部分卡表，那么会对应64张卡，即32KB的内存。如果同时有两个Java线程，在这32KB内存中进行引用更新操作，那么也将造成存储卡表的统一部分的缓存行的写回，无效化或者同步操作）引入了一个参数，**（-XX:+UseCondCardMark）**。

### 5.3 垃圾回收器

- 新生代的垃圾回收器（标记复制）：
  - Serial：单线程的
  - Parallel Scavenge：Serial的多线程版本（与CMS无法共用）
  - Parallel New：和上个类似，更加注重吞吐率。
- 老年代的垃圾回收器（标记压缩）：
  - Serial Old：单线程
  - Parallel Old：前者多线程版本
  - CMS：标记-清除（并发），仅有少数几个操作需要STW之外，可以在应用程序运行过程中进行垃圾回收。并发收集失败的情况下。Java虚拟机会使用其他两个压缩型垃圾回收器 进行一次垃圾回收。Java9废弃
- G1：横跨新生代和老年代的垃圾回收器。直接将堆分成极多个区域，每个区域都可以充当Eden，Survivor或者老年代的一个，使用的是标记压缩算法，而且可以和CMS一样能够在运行中并发的进行垃圾回收。针对每个细分的区域来进行垃圾回收，会优先回收死亡对象较多的区域。



