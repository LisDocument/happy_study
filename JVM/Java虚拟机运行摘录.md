# Java虚拟机运行摘录

- 虚拟机带来一个托管环境。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。最广为人知的就是自动内存管理和垃圾回收。还提供了诸如数组越界，动态类型，安全权限等等的动态检测，是我们免于写这些无关与业务逻辑的代码。

- 运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。栈帧大小是提前计算好的，且Java虚拟机**不要求栈帧在内存空间内连续分布**。退出当前执行的方法的时候，不管是正常返回还是异常返回，Java虚拟机均会弹出当前栈帧，将之舍弃。

- HotSpot中，解释Java执行有两种形式，HotSpot默认采用混合模式，综合解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点，以方法为单位进行即时编译。（即时编译建立在符合二八定律的假设上）
  
  [^热点]: 在git里面涉及到的热点代码有两种算法，基于采样的热点探测和基于计数器的热点探测。一般采用的都是基于计数器的热点探测。基于计数器的热点探测又有两个计数器，方法调用计数器，回边计数器，默认2000调C1，15000调C2。
  
  - 解释执行：逐条将字节码翻译成机器码并执行。优势在于无需等待
  - 即时编译（JIT）：讲一个方法中包含的所有字节码编译成机器码后再执行。优势在于实际运行速度更快，这个执行效率甚至可能高于C++，**因为和静态编译比，即时编译拥有程序的运行时信息，并且能根据这个信息作出相应的优化**（多态）

![img](Java虚拟机运行摘录.assets/5ee351091464de78eed75438b6f9183b.png)

- HotSpot内置的即时编译器，Java7开始就使用分层编译，热点方法先被C1编译，热点方法的热点被C2编译
  - C1：Client编译器，面向对启动性能有要求的客户端GUI程序，优化手段相对简单，编译时间短
  - C2：Server编译器，面向对峰值性能有要求的服务器端程序，采用优化手段相对复杂，编译时间长，生成代码执行效率高
  - Graal（Java10引入的实验性即时编译起）
- HotSpot的即时编译时异步进行的，为了不干扰应用的正常运行，HotSpot会根据CPU的数量设置编译线程的数据，并且按照1:2的比例给C1及C2编译器。



















