# MySQL怎么给字符串加索引呢

在检索的时候如果需要检索的字段上没有索引，那么这个语句就只能做全表扫描。

因此对部分需要检索的字段，就需要加入索引来提高查询效率，那么如果是字符串加入的话，需要怎么优化呢

MySQL支持前缀索引。即可以定义字符串的一部分作为索引。如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

- 使用全部索引的话
  - 从索引树上找到满足索引值是**对应值**的记录，取得id的值，回表**再次**判断值是否正确，正确将这行记录加入结果集，索引树上下一条记录不满足条件了，跳出循环。这个过程，仅需回表依次
- 使用前缀索引的话
  - 在索引树上找到满足索引值是**对应值前缀**的记录，找到数据，然后通过回表查询对应行并且匹配，成功加入结果集失败丢弃，一直重复直到前缀已经越过为止

对于上述行为的对比，可以发现，如果前缀定义的宽泛的情况下，会导致查询语句读数据的次数变多。

因此，得出结论， **<u>使用前缀索引，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本</u>**

## 使用前缀索引减少索引空间我们该怎么做呢

建立索引时关注的是**区分度**，**基数**越多，意味着索引产生的多次查询越少

- 首先计算该列有多少个不同的值
- 然后依次选择不同长度的前缀来看这个值，比较对应字节的前缀索引
- 使用前缀索引很有可能会损失区分度，因此需要预先设定一个可以接受的损失比例，然后在查询的结果中，寻找损失少于该值的，再参考使用多少字段的前缀索引

## 如果使用前缀索引，势必会对覆盖索引产生影响

当查询希望返回的结果是id和原字段的时候，使用前缀索引会增加扫描行数，这会影响到性能。

因为使用前缀索引后，索引内容无法覆盖原字段，仍旧需要回表来获取原字段内容，而使用覆盖索引可以不回表直接返回。<font color=red>由于无法确认前缀索引定义是否截断了完整信息，因此就算使用尽可能包含所有内容的前缀索引，InnoDB依旧会回表</font>

## 对于前缀索引的使用，依旧还是看业务

对于很多种情况下，其实前缀索引并不能很好的处理业务上的问题，对于身份证号来说，一个市的公民信息系统，必须要创建长度为12以上的，才能够满足区分度要求。但是索引越长，占用空间越大，相同数据页放下的索引内容也就少，搜索效率页会变低。

- **倒序存储**，如果存储身份证号的时候倒过来存储，每次查询的时候

  ```mysql
  mysql> select field_list from t where id_card = reverse('input_id_card_string');
  ```

- **使用hash字段**，在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段中建立索引，每次插入新记录的时候，同时用crc32()这个函数得到这个新字段。但是参照Java中的HashMap，得到的hash值会出现hash冲突，hash可能会有相等情况，因此需要同时判断对应字段的值是否相同才行

  ```mysql
  # 添加字段
  mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);
  # 查询
  mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
  ```

对于这两种方案，有一定区别，主要表现在

- 占用空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，hash需要再加一个字段，当然，倒序存储方式使用4个字节的前缀长度一般是不够的，如果再长点，其消耗也约等于hash了
- CPI消耗上，倒序方式写和读的时候，都要额外调用依次reverse函数，hash要调用依次crc32()函数。如果只从计算复杂度来看，reverse函数的CPU消耗会小一些
- 查询效率上，hash字段更稳定一些，因为crc32()算出来虽然会有冲突但几率较小，因此可以默认认为平均每次扫描行数接近1。而倒序用的还是前缀索引的方式，可能还会增加扫描行数



