# MySQL的随机取值

## 内存临时表

如果当前需求是10000行记录中要随机选择3个

```mysql
mysql> select word from words order by rand() limit 3;
```

使用explain中可以看到Extra中显示Using temporary，Using filesort，这里前者表示需要使用临时表，后者表示需要进行排序，综合这个意思为，需要用到临时表，并且需要在临时表上排序。

按照orderby的算法和结论来说（InnoDB中，执行全字段排序会减少磁盘访问，因此会被优先选择）

> ps：仅仅是InnoDB

对于**内存表**来说，回表过程只是简单地根据数据行地位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器少了对回表这一操作地顾虑，那么优先考虑地就是排序地行越小越好，因此MySQL此时会选择rowid排序。

### 综上所述，得出语句执行流程大约如下

1. 创建临时表，使用memory引擎，表里两个字段，第一个是double类型，当前记作R，第二个是varchar，记作W，且此表没有索引
2. 从words表中，按照主键顺序取出word值，对于每个word值，调用rand()函数生成一个0-1地随机小数然后存入临时表的RW中，到此扫描的是全表行数
3. 此时临时表有10000行数据了，然后再没有索引的内存临时表上，按照字段r排序
4. 初始化sort_buffer。两个字段，R，W
5. 从内存临时表一行行的取出R和**位置信息**，分别存入sort_buffer的两个字段中，这个过程会对内存临时表全表扫描，此时行数已经是全表行数*2
6. 在sort_buffer中根据R的值进行排序
7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端，这个过程，访问了表的三行数据，因此最后扫描数为全表行数*2+3

###  MySQL的表是用什么方法来定位“一行数据”的

首先，明确一点，如果把一个InnoDB表的主键删掉，是不是没有主键就没办法回表了。

- 如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB回自己生成一个长度为6字节的rowid来作为主键。

这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。

- 对于有主键的InnoDB来说，这个rowid就是主键ID
- 对于没有主键的InnoDB来说，这个rowid就是系统生成的
- MEMEORY引擎不是索引组织表。在这个例子里，你可以认为它就是一个数据，因此，这个rowid其实就是数组的下标

## 磁盘临时表

当然不会是所有临时表都是内存表，那样的话如果是大表的话内存就炸了。

**tmp_table_size**这个配置限制了内存临时表的大小，默认是16M，如果临时表的大小超过了这个数，内存临时表就会转成磁盘临时表

磁盘临时表使用的引擎默认是InnoDB，是由参数**internal_tmp_disk_storage_engine**控制的，当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。

依旧对上述语句进行查询，通过修改参数保证当前查询会使用磁盘临时表。

R存放的随机值是8个字节，rowid是6个字节，数据总行数是10000，那么算出来就有140000字节了，超过sort_buffer_size的定义了，但是查询结果使用的number_of_tmp_files值却是0

这个SQL语句排序确实没有用到临时文件，采用5.6新引入的排序（优先队列排序算法）。

我们当前用来查询的SQL语句，只需要R最小的3个rowid。但是用归并排序的话，虽然最终也能得到前三个值，但是算法结束，10000行数据也已经排好序了，即后面的9997条数据也是有序的了，但是我们的查询并不需要这些数据有序，这就浪费了很多的计算量

因此使用优先排序算法

1. 对于这10000个准备排序的（R，rowid），先取前三行，构造成一个堆
2. 取下一行（R1，rowid1），和当前堆里最大的R比较，如果R1小于R，把这个（R，rowid）从堆中去掉，替换为新的
3. 重复2，知道10000个完成（舍弃是看需要多少数）

但是对于OrderBy中的例子，limit 1000的时候为什么没有用优先排序算法呢

- 这条语句如果使用优先队列算法的话，需要维护的堆的大小就是1000行，超过设置的sort_buffer_size的大小，因此只能使用归并排序

### 总之无论使用那种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要扫描大量的行数，资源消耗会很大

## 那么有什么比较好的优化方案么

### 通过id范围获取随机id

```mysql
mysql> select max(id),min(id) into @M,@N from t ;
set @X= floor((@M-@N+1)*rand() + @N);
select * from t where id >= @X limit 1;
```



对于id是数字型的来说，可以获取这个表id的最大最小值，然后使用随机算法获取随机id，然后根据这个随机id直接获取值

max(id),min(id)都是不需要扫描索引的，而直接**根据随机id获取比他大的第一个值**也是可以使用索引快速定位，因此可以认为只扫描了3行。但是这个算法并不能严格满足于要求，因为id中间可能有空洞，因此选择不同行的概率不一样

### 通过总行数取随机行号获取

```mysql
mysql> select count(*) into @C from t;
set @Y = floor(@C * rand());
set @sql = concat("select * from t limit ", @Y, ",1"); # 由于limit后面不能跟变量
prepare stmt from @sql;
execute stmt;
DEALLOCATE prepare stmt;
```

这个处理就会按顺序一个一个读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。第一步要扫描C行，因此其实总共要扫描C+Y+1行，执行代价高于前者