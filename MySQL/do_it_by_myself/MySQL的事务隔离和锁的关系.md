# 事务究竟是隔离还是不隔离呢

前提：

- 事务隔离级别中提到，如果是可重复读隔离介别，事务T启动的时候会创建一个视图read-view，然后事务执行期间，即使有其他的事务修改了数据，事务T看到的仍然跟启动时看到的一样。也就是说。一个可重复读隔离介别下执行的事务，好像与世无争，不受影响
- 行锁中提到，一个事务要更新一行，如果刚好有另一个事务拥有这一行的行锁，他又不能那么超然了，会被锁住，进入等待状态，那么进入等待状态后这个事务自己获取行锁需要更新数据的时候，他读到的值又是什么呢

begin/start transaction并不是事务的起点，在**执行他们之后的第一个操作InnoDB的语句事务才真正启动**。如果想要立即启动需要使用**start transaction with consistent snapshot**命令

- 一致性视图是在第一个快照读语句时创建的
- 一致性视图是在执行**start transaction with consistent snapshot**时创建的

> 事务没有显式地使用begin/commit，表示这个语句本身就是一个事务，语句完成后自动提交

## 快照如何在MVCC中工作

> 事务创建快照的时候**不是拷贝**的

InnoDB里的每个事务都有一个唯一的事务ID，叫做transation id。在事务开始的时候向InnoDB的事务系统申请，按申请顺序严格递增。

对于InnoDB的每个数据也是有多个版本的，每次事务更新数据的时候，会生成一个新的数据版本，并把transaction id赋值给这个数据版本的事务id，记为row trx_id。同时保留旧的版本，且在新的数据版本中，能有消息可以直接拿到他

![68d08d277a6f7926a41cc5541d3dfced](MySQL的事务隔离和锁的关系.assets/68d08d277a6f7926a41cc5541d3dfced.png)

上图就是记录多个事务连续更新一条记录的状态。

语句更新产生的undo log是图中的三个虚线箭头。且这三个不是物理上真实存在的，存储的是向量，如果要获取V2的时候就是通过V3依次执行U3，U2后计算出来的。

对于事务启动后说：以启动时刻为主，只认我启动时间之前的数据，不认启动后的，如果遇到启动后的，回溯到启动前的时间版本使用（当然除了自己的以外）。

实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间。当前正在活跃的所有事务ID。活跃是**启动了未提交**，数组中ID最小值为低水位，ID最大值加1为高水位。视图数组和高低水位。组成了当前事务的一致性视图。

数据版本的可见性规则，就是基于数据的row trx_id和一致性视图对比结果得到的

![882114aaf55861832b4270d44507695e](MySQL的事务隔离和锁的关系.assets/882114aaf55861832b4270d44507695e.png)

对于当前事务启动瞬间来说，一个数据版本的row trx_id有以下可能

- 绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的。这个数据可见
- 红色部分，这个版本是未来的启动事务生成的。不可见
- 黄色部分
  - row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见
  - 不在数组中，表示这个版本是已经提交了事务生成的，可见

在如此概念下，系统随后发生的更新，就与这个事务看到的内容无关了。

<u>但是考虑到一种情况，在事务A中准备更新某个字段，事务B优先于事务A的操作（即事务A已经创建好视图，但是未更新字段的时候），事务B已经更新好了字段并提交事务，这种情况下，事务A是在原来的数据下更新还是事务B的数据下更新？</u>

**<u>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</u>**

除了update语句外，select语句如果加锁（加上lock in share model或for update），也是当前读

```mysql
select k from t where id = 1 lock in share mode
select k from t where id = 1 for update
```

<u>但是如果上述情况中，事务B虽然更新好了数据，但是事务未提交呢，而此时让事务A继续去更新该行数据会发生什么。</u>

**<u>两阶段锁协议，事务B虽然没提交但是数据版本已经正常更新了，可是由于两阶段锁协议，使用时加锁和事务结束后释放锁，导致事务中该行的行锁未释放，而事务A是当前读，当前读必须要读最新版本且必须加锁，因此就被锁住了等待事务B提交后才能继续当前读</u>**



> PS：
>
> - 对于可重复读，查询只承认在事务启动前就已经提交的数据
> - 对于读提交，查询只承认在语句启动前就已经提交的数据

表结构当前不支持**可重复读**，这是因为表结构没有对应的行数据，也没有row trx_id，因此只能当前读。

但是8.0后可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复读

## GAP锁

### 错误例子方案1

![5bc506e5884d21844126d26bbe6fa68b](MySQL的事务隔离和锁的关系.assets/5bc506e5884d21844126d26bbe6fa68b.png)

可以见到这里sessionA执行了三次查询，分别是Q1，Q2，Q3。他们的sql语句相同，都是当前读且加上写锁获取所有d=5的行

当然这里Q3中读到id=1的现象被称为幻读，即**幻读指一个事务前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行**

当然这里出现幻读是因为加了for update，是当前读，本来就能看到记录的最新值，这跟事务的可见性规则并不矛盾，但是这里还是有问题的

- 语义上被破坏，Q1语句的实际意义其实是锁住所有d=5的行，不让别的事务进行读写操作，但是实际上，在这里，这个语义被破坏了。

- 数据一致性上的问题，锁的设计本来就是为了保证数据的一致性，而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。

  ![dcea7845ff0bdbee2622bf3c67d31d92](MySQL的事务隔离和锁的关系.assets/dcea7845ff0bdbee2622bf3c67d31d92.png)

  这个执行的过程是：

  1. 经过T1，id=5这一行变成（5，5，10），但是这个结果是在T6时刻正式提交的
  2. 经过T2，id=0这一行变成（0，5，5）
  3. 经过T4，表里多了一行（1，5，5）
  4. 其他行跟这个执行序列无关，保持不便

  此时binlog里面的内容是这样的：

  1. T2时刻，sessionB事务提交，写入两条语句
  2. T4时刻，sessionC事务提交，写入两条语句
  3. T6时刻，sessionA事务提交，写入update t set d = 100 where d=5 这条语句

  直观的看大概是这样的

  ```mysql
  update t set d=5 where id=0; /*(0,0,5)*/
  update t set c=5 where id=0; /*(0,5,5)*/
  
  insert into t values(1,1,5); /*(1,1,5)*/
  update t set c=5 where id=1; /*(1,5,5)*/
  
  update t set d=100 where d=5;/*所有d=5的行，d改成100*/
  ```

  然后这个binlog以后克隆的库，结果都是（0，5，100），（1，5，100），（5，5，100）

  针对前面的数据，发生了数据完全不一致，**这是很严重的**

### 错误例子方案2

上面的例子肯定是有问题的，那么我们假设这个问题是因为行锁只对当前行有效导致的，需要把扫描过程中碰到的行，也加上行锁

那么sessionA把所有的行都加了写锁，所以sessionB在执行第一个update语句的时候直接锁住了，需要等sessionA提交后，sessionB才能执行，但是sessionC依旧在执行，会导致之后依旧出现了（1，5，100），这个幻读的问题依旧没有解决，我们已经把所有记录都上了锁，但是还是阻止不了新增这个动作

这就是幻读的定义和幻读的区分，其实这里的幻读，更重要的立于日志和数据的统一性

### 那么MySQL的间隙锁应运而生

在RR隔离级别下，readview会在当前事务首次执行SELECT快照读的时候创建。即事务1先执行，但是没有继续宁SELECT快照读操作，此时事务2插入了一条记录并提交，事务1是可以看到事务2插入的数据的。因为按照MVCC实现原理，当事务1查询事务2插入的行时，该行记录上的隐藏事务id字段并不会在事务1新创建的readview活跃事件列表中，而且小于readview创建的高水位，所以是可见的。在RR隔离级别下，当前事务没有提交，快照读操作始终读到的都是第一次执行select找到的快照版本。倘若其他事务执行了Insert操作，而当前事务执行了任何的当前读操作（update，delete，select .. from update等）,还是会出现幻读。

GAP时InnoDB在可重复读的隔离级别下引入的锁机制

1. Record Lock：单个行记录上的锁
2. Gap Lock: 间隙锁，锁定一个范围，不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况
3. Next-Key Lock: 1+2,**锁定一个范围，并且锁定记录本身**。对于行的查询。都是使用该方法，主要目的是为了解决幻读的问题

例子：

事务A，事务B，c索引，c中有值1，3，5，8，11

事务A开启事务，并且使用当前读读取了c=8的记录，事务未释放。

事务B开启事务，并且开始插入数据c=2,c=4,c=6,c=7,c=9,但是在插入6789的时候，开始锁等待。

**考虑**：InnoDB的行锁，在事务A中锁住c=8，其他应该不受影响

**分析**：事务对行的查询采用Next-Key Lock的算法，锁住的不是单个值，而是一个范围（GAP）,上面索引值有1，3，5，8，11，对于其记录的GAP的空间如下:是个左开右闭的空间

（-无穷，1],(1,3],(3,5],(5,8],(8,11],(11,无穷),

InnoDB还会对辅助索引下一个键值加上gap lock。

事务A锁定了5-8，下一个键值范围是8-11，即5-11都会被锁定要求等待。因此插入非这个范围内都正常

当查询的索引含有**唯一**属性的时候，Next-Key Lock会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。通过主键或者唯一索引来锁住不存在的值，也会产生GAP锁定。

**整理**：

1. 加锁的基本单位是next-key lock，遵循前开后闭原则，对闭合的索引采用行锁。区间范围是间隙锁，**锁住的是insert操作**。
2. 插序的过程中访问的对象会增加锁
3. 索引上的等值查询--给唯一索引加锁的时候，next-key会降级为行锁**（优化）**
4. 索引上的等值查询--向后遍历最后一个值不满足查询要求时，行锁会进化成间隙锁**（优化）**
5. 唯一索引上的范围查询到不满足条件的第一个值为止

### 一些有趣的例子

```mysql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

id是int类型的其实这两句是等价的，但是加锁规则不一样，第一个语句加锁比较好理解，第二个我们来捋一捋

1. 开始执行的时候，要找到一个id=10的行，因此本该是next-key lock(5,10]。根据优化1，主键索引是唯一索引，退化为行锁，因此锁住了id=10这一行
2. 范围查找继续往后，找到id=15这条记录上停下来。所以这里锁住了(10,15]

当然如果id<=15呢，其实id是唯一键，循环应该到15这一行停止，然而并不是，直到id=20（下一个记录）的时候才结束，因此锁住了(15,20],这或许是个bug

> ps：如果考虑到对应字段相同，那么索引上是不是没有间隙了呢，其实不是的，普通索引都携带了索引值和id，这两个构成了一个唯一值的键，因此其实还是存在间隙的，但是这个间隙可能体现在id上

#### limit的优势

在很多情况下使用limit可以避免第五条件的范围锁，使用limit满足条件后，对后面的记录就不会加锁了，即在delete的时候，可以尽量使用limit，又能保证删除的数量不会出错，又能减少锁的范围

### 间隙锁的缺点



![df37bf0bb9f85ea59f0540e24eb6bcbe](MySQL的事务隔离和锁的关系.assets/df37bf0bb9f85ea59f0540e24eb6bcbe.png)

间隙锁之间是不会冲突的，因此sessionA和sessionB的间隙锁都是正常上锁，然而上锁后，B接下来的操作被A的间隙锁锁住，而A也被B的间隙锁锁住，由此造成死锁。

因此说，间隙锁的引入，可能会导致同样的语句锁住更大的方位，这其实是影响了并发度的。

当然考虑的RR环境下才会有间隙锁，因此只要把隔离级别设置为RC的话，间隙锁就没有了，但是需要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。当然这种操作的执行，也要考虑业务场景来进行具体分析了