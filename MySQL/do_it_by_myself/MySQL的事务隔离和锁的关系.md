# 事务究竟是隔离还是不隔离呢

前提：

- 事务隔离级别中提到，如果是可重复读隔离介别，事务T启动的时候会创建一个视图read-view，然后事务执行期间，即使有其他的事务修改了数据，事务T看到的仍然跟启动时看到的一样。也就是说。一个可重复读隔离介别下执行的事务，好像与世无争，不受影响
- 行锁中提到，一个事务要更新一行，如果刚好有另一个事务拥有这一行的行锁，他又不能那么超然了，会被锁住，进入等待状态，那么进入等待状态后这个事务自己获取行锁需要更新数据的时候，他读到的值又是什么呢

begin/start transaction并不是事务的起点，在**执行他们之后的第一个操作InnoDB的语句事务才真正启动**。如果想要立即启动需要使用**start transaction with consistent snapshot**命令

- 一致性视图是在第一个快照读语句时创建的
- 一致性视图是在执行**start transaction with consistent snapshot**时创建的

> 事务没有显式地使用begin/commit，表示这个语句本身就是一个事务，语句完成后自动提交

## 快照如何在MVCC中工作

> 事务创建快照的时候**不是拷贝**的

InnoDB里的每个事务都有一个唯一的事务ID，叫做transation id。在事务开始的时候向InnoDB的事务系统申请，按申请顺序严格递增。

对于InnoDB的每个数据也是有多个版本的，每次事务更新数据的时候，会生成一个新的数据版本，并把transaction id赋值给这个数据版本的事务id，记为row trx_id。同时保留旧的版本，且在新的数据版本中，能有消息可以直接拿到他

![68d08d277a6f7926a41cc5541d3dfced](MySQL的事务隔离和锁的关系.assets/68d08d277a6f7926a41cc5541d3dfced.png)

上图就是记录多个事务连续更新一条记录的状态。

语句更新产生的undo log是图中的三个虚线箭头。且这三个不是物理上真实存在的，存储的是向量，如果要获取V2的时候就是通过V3依次执行U3，U2后计算出来的。

对于事务启动后说：以启动时刻为主，只认我启动时间之前的数据，不认启动后的，如果遇到启动后的，回溯到启动前的时间版本使用（当然除了自己的以外）。

实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间。当前正在活跃的所有事务ID。活跃是**启动了未提交**，数组中ID最小值为低水位，ID最大值加1为高水位。视图数组和高低水位。组成了当前事务的一致性视图。

数据版本的可见性规则，就是基于数据的row trx_id和一致性视图对比结果得到的

![882114aaf55861832b4270d44507695e](MySQL的事务隔离和锁的关系.assets/882114aaf55861832b4270d44507695e.png)

对于当前事务启动瞬间来说，一个数据版本的row trx_id有以下可能

- 绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的。这个数据可见
- 红色部分，这个版本是未来的启动事务生成的。不可见
- 黄色部分
  - row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见
  - 不在数组中，表示这个版本是已经提交了事务生成的，可见

在如此概念下，系统随后发生的更新，就与这个事务看到的内容无关了。

<u>但是考虑到一种情况，在事务A中准备更新某个字段，事务B优先于事务A的操作（即事务A已经创建好视图，但是未更新字段的时候），事务B已经更新好了字段并提交事务，这种情况下，事务A是在原来的数据下更新还是事务B的数据下更新？</u>

**<u>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</u>**

除了update语句外，select语句如果加锁（加上lock in share model或for update），也是当前读

```mysql
select k from t where id = 1 lock in share mode
select k from t where id = 1 for update
```

<u>但是如果上述情况中，事务B虽然更新好了数据，但是事务未提交呢，而此时让事务A继续去更新该行数据会发生什么。</u>

**<u>两阶段锁协议，事务B虽然没提交但是数据版本已经正常更新了，可是由于两阶段锁协议，使用时加锁和事务结束后释放锁，导致事务中该行的行锁未释放，而事务A是当前读，当前读必须要读最新版本且必须加锁，因此就被锁住了等待事务B提交后才能继续当前读</u>**



> PS：
>
> - 对于可重复读，查询只承认在事务启动前就已经提交的数据
> - 对于读提交，查询只承认在语句启动前就已经提交的数据

表结构当前不支持**可重复读**，这是因为表结构没有对应的行数据，也没有row trx_id，因此只能当前读。

但是8.0后可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复读

