# MySQL的事务隔离

## 隔离性与隔离介别

ACID：Atomicity原子性，Consistency一致性，Isolation隔离性，Durability持久性

当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)，不可重复读（non-repeatable read），幻读（phantom read）的问题，因此推出了**隔离级别**的概念

隔离级别越高，效率越低

SQL标准的事务隔离级别包括

- 读未提交：一个事务还没提交时，他做的变更就能被别的事务看到
  - 如果事务A对表进行了修改，但是事务A还未提交，但是此时事务B已经能够看到A修改的数据了
- 读提交：一个事务提交之后，他做的变更才能被其他事务看到
  - 如果事务A对表进行了修改，但是事务A还未提交，事务B无法看到事务A的修改，<u>但是此时如果事务A提交了，事务B依旧未提交</u>，此时事务B也可以获取到事务A的修改
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的
  - 如果事务A对表进行了修改，但是事务A还未提交，事务B无法看到事务A的修改，但是此时如果事务A提交了，事务B依旧未提交，此时事务B<u>无法</u>获取到事务A的修改，<u>但是对于重新开始的事务C，是可以看到事务A的修改结果的，即事务中保证读到的数据前后一致</u>
- 串行化：顾名思义是对同一行记录，**写**会加**写锁**，**读**会加**读锁**。当出现冲突的时候，按后一个等待前一个完成执行
  - 约等于锁

## 事务隔离的实现

数据库会创一个视图，访问时以视图的逻辑结果为准。在**可重复读**的隔离级别下，这个视图是在事务启动时创建的，整个事务的存在期间都使用这个试图。在**读提交**的隔离级别下，这个视图实在每个SQL语句开始执行时创建的。

*注意：**读未提交**隔离级别下直接返回记录上的最新值，没有视图概念；**串行化**直接使用加锁*

*ORACLE默认为**读提交**，如果出现ORACLE迁移MySQL的话，记得设置MySQL的隔离级别为**读提交***



### 实现以及回滚

MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值

#### 回滚段

如果一个值从1被依次改为2，3，4，那么回滚日志里存在回滚段undolog（2-1，3-2，4-3）这三个回滚段，在值为1的情况下，开启了一个事务A使用该值，事务A中该值为1，在值被改为2后，事务B开启同时使用该值，即事务B中该值为2，接着在值已经是4的情况下，事务C获取并修改其值为5，即在这个事务C中该值为5。那么当前对于该值来说，视图A（对应事务A，由此类推）中的值为1，视图B中的值为2，视图C中的值为5，同一条记录在系统中可存在多个版本，这就是数据库的**多版本并发控制**(MVCC)。对于视图A，要得到1，就必须将当前值做4-3，3-2，2-1的回滚操作后得到。同时这三个事务是不会发生冲突的。

#### 回滚段的保留

在不需要的时候会进行删除，当没有事务用到这些回滚日志的时候，回滚十日会被删除，即当前如果事务A提交了，视图A对应消息，回滚日志页会删除2-1的回滚操作。

> PS:由此，尽量避免使用长事务，长事务意味着系统里会存在很老的事务视图，由于这些事务随时可能访问数据库的任何数据，所以这个事务提交前，数据库里面可能用到的回滚记录都必须保留，**会占用大量的存储空间**。除了对回滚段的影响，长事务还**占用锁资源**，可能会拖垮整个库

### 配置

```mysql
show variables like 'transaction_isolation'
```

通过show variables可以查看当前的数据隔离级别

可通过将启动参数**transation-isolation**设置事务隔离级别

查询长事务

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(), trx_started)) > 60
```

