# MySQL误删数据

## 误删行

[MySQL的主备一致](MySQL的主备一致.md)中提到关于binlog日志格式中也有提到，如果用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复过来。

Flashback恢复数据的原理，是修改binlog的内容，拿回库里重放，而能够使用这个方案的前提是，需要保证binlog_format=row和binlog_row_image=FULL。

恢复数据时具体的对单个事务做如下处理：

1. 对insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可。
2. 同理，对于delete语句，将Delete_rows event 改为Write_rows event；
3. 如果是Update_rows的话，binlog记录了数d据行修改前后的值，对调这两个的位置即可

如果不是单事务的话，在Flashback工具解析binlog后，逆序执行恢复操作，具体恢复操作可参照单个事务的操作。

不推荐直接在主库上执行这些操作。可以恢复出一个备份，或者获取一个从库作为临时库，在临时库上执行这些操作，然后将确认过的临时库数据恢复回主库。因为一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据的问题晚了一点儿，就导致已经在之前误操作的基础潮，业务代码逻辑又继续修改了其他数据。所以这时候单独回复这几行数据，而又未经确认的话，可能出现对数据的二次破坏。

### 事先预防

1. 把**sql_safe_updates**参数设置为on，那么如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句执行就会报错。
2. 代码上线前，必须经过SQL审计。

如果需要delete全表的话，可以使用where id > 0这样的操作来躲过检验，但是delete全表是很慢的，需要生成回滚日志，写redo写binlog，从性能上考虑，应该优先使用truncate table或者drop table命令。但是这种命令就没办法用flashback来恢复了，因为即使我们配置了binlog_format=row，执行这几个命令的时候，记录的binlog还是statement格式，binlog里面就只有一个truncate/drop语句，这些信息是恢复不了数据的。

## 误删库/表

### binlog恢复

这种情况下想要恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。

这种条件具备的情况下，恢复的流程如下：

1. 取最近一次全量备份，假设这个库是一天一备，上次备份时间是当天0点
2. 用备份恢复出一个临时库；
3. 从日志备份里面，取出凌晨0点之后的日志；
4. 把这些日志，出了误删除数据的语句外，全部应用到临时库

这恢复过程中，可以注意这几点：

1. 为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用mysqlbinlog命令时加一个-database参数，用于指定误删表所在的库。这样就变面了再恢复数据时还要应用其他库日志的情况
2. 在应用日志的时候，需要跳过误操作的那个语句的binlog：
   1. 如果原实例没有使用GTID模式，只能在应用包含误删除操作的binlog文件时，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行；
   2. 如果实例采用了GTID模式，只需要执行set gtid_next=gtid1（删除数据的那个语句的gtid）;begin;commit;先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，会自动跳过删除的语句。

但是即便是使用mysqlbinlog方法恢复数据还是不够快

1. 如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能这样指定
2. 用mysqlbinglog解析出日志应用，应用日志的过程中就只能是单线程。

### binlog恢复加速的方案

在用备份恢复出临时实例后，将这个临时实例设置为线上备库的从库

1. 在start slave之前，先通过执行 change replication filter replicate_do_table = (删除的table),就可以让临时库只同步误操作的表；
2. 这样做可以用上并行复制技术，加速整个数据恢复过程。

binlog备份系统到线上备库其实是不稳定的，因为备库上可能已经删除了临时实例需要的binlog， 即临时实例需要的是从master.00005开始的，线上的binlog最小的已经是master.00007了，即少了两个binlog文件，那么就需要去binlog备份中找到这两个放到备库中让备库识别，然后备库就拥有了临时库需要的所有的binlog了，建立主备关系，就可以正常同步了。

### 延迟复制备库

虽然可以通过并行复制来加速恢复数据的过程，但是这个方案仍旧存在恢复时间不可控的问题。

如果一个库的备份特别大，可能就不是一天一备的， 假如是一周一备的实例，那么备份后的第六天发生误操作，就需要恢复6天的日志，这个时间可能是按天来计算的。

可以考虑搭建延迟复制的备库。MySQL5.6以上。

延迟复制的备库是一种特殊的备库，通过CHANGE MASTER TO MASTER_DELAY=N命令，可以指定这个备库持续保持跟主库有N秒的延迟。

如果把N设置为3600，如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，那么就没有在这个延迟复制的备库执行，这时候只需要在备库中执行stop slave命令，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。那么这样最多只需要再追1小时，就可以恢复出数据的临时实例，缩短了整个数据恢复需要的时间。

### 预防

#### 账号分离

- 给业务发开DML权限，不给truncate/dtop权限，如果有DDL需求的话，可以通过开发管理系统得到支持
- 即使DBA团队，日常也只使用只读账号，必要才使用有更新权限的账号

#### 制定操作规范

- 在删除数据标签，必须先对表做改名操作，观察一段时间后确保对业务无影响后在删除。
- 改表名时，添加固定的后缀，删除表的动作必须通过管理系统执行，且管理系统删除表的时候，只能删除固定后缀的表

## rm删除数据

对于高可用的MySQL集群来说，这个一般不会有问题，删除一个节点的数据的话，HA系统会开始工作，选出一个新的主库，保证整个集群的正常工作。

我们只需要在这个节点上把数据恢复回来，再接入整个集群即可。



## 其他

http://blog.itpub.net/26736162/viewspace-2672595/