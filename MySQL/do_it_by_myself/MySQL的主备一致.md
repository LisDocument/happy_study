# MySQL的主备一致

首先要明确，主备一致主要是因为binlog

一般把备库设置为readonly状态来判断节点的角色。虽然设置为只读，但是这里的设置对超级权限用户是无效的，而用于同步更新的线程，就拥有超级权限。

![a66c154c1bc51e071dd2cc8c1d6ca6a3](MySQL的主备一致.assets/a66c154c1bc51e071dd2cc8c1d6ca6a3.png)

上图就是主库A和备库B之前的同步逻辑。

1. 在备库B上通过change master命令，设置主库A的IP，端口，用户名，密码以及从哪个位置开始请求binlog，这个位置包括文件名和日志偏移量。
2. 在备库B上执行start slave命令，这时候备库会启动两个线程，即IO-thread和sql-thread，其中io-thread用于和主库建立连接
3. 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B
4. 备库B拿到binlog后，写到本地文件，称为中转日志（relay log）
5. sql-thread读取中专日志，解析出日志中的命令并执行

后来引入了多线程复制方案，sql-thread演化为了多个线程

## binlog的三种格式对比

- statement：记录真实执行的语句，包括切库，事务开始和结束（这样能保证日志传到备库去执行的时候，不论当前工作线程在哪个数据库，都能够正确更新）最后一行是事务的commit 里面记录了xid

  - 由于主备数据库的数据可能会有不一致的情况，因此在执行有一些命令的时候，得到的效果可能会和主库有出入，例如执行delete语句的时候携带了limit，这样就会导致命令是unsafe的，当然也有可能由于索引使用有差异导致得到的接口会有区别。这样被认为是有风险的

- row：删除了statement中执行SQL原文的位置，换成了两个event

  - Table_Map event： 接下来操作的是表是test库的t表

  - Delete_rows event：定义删除的行为

    但是row方式的binlog我们是没办法看到详细信息的，需要借助mysqlbinlog工具,startposition参数定义解析日志的起始位置，vv可以把内容都解析出来

    ```mysql
    mysqlbinlog  -vv data/master.000001 --start-position=8900;
    ```

    **binlog_row_image**的默认配置是FULL，因此event中包含了操作行的所有字段的值，如果这个设置为MINIMAL，只会记录必要的信息，可能是id或者别的

    因此当binlog使用row格式的时候，binlog里面记录了真实删除行的主键id，当binlog传到备库去的时候，就肯定会删除id=4的行。就不会有主备删除不同行的问题。

- mixed： 
  - 因为statement格式的binlog可能会导致主备不一致
  - 但是用row 有很占空间，如果一个delete删掉10w行数据，那么row就会把10w条数据写道binlog中，消耗IO资源影响执行速度
  - 然后MySQL就取了个这种方法，就是mixed的binlog，如果MySQL判断这个主句可能会导致主备不一致，那么使用row，不然的话使用statement格式，因此又具备了statement格式的有点，同时避免了数据不一致的风险。

当然对于更多的场景其实把binlog设置为row是由很大好处的。至少有一个可以直接看出来的好处：**恢复数据**

- 即使执行的是delete语句，row格式的binlog也会把删掉的数据整行信息保存起来，那么可以把binlog中记录的delete语句转成insert，直接插回去尽可以恢复了。
- insert语句，row下binlog会记录所有字段信息，直接把insert转为delete删除掉即可
- 如果执行的是update语句的话，binlog会记录修改前和修改后的整行数据，如果误执行了update，只需要把这两个event对调执行即可

mixed格式的小计：如果插入语句使用了now函数，statement会在执行这句语句前set timestamp=xxxx，保证下面now函数和主库相同

## 循环复制的问题

正常情况下主备的数据是一致的，但是生厂上用的比较多的是双M结构。互为主备关系，在切换的时候就可以不用在修改主备关系。

但是由于binlog在双节点可能都会生成（**log_slave_updates**为on，表示备库执行relay log后生成binlog）。那如果binlog互相传递，那么很有可能导致循环执行这个更新语句，虽然可能数据最终不会有所改变，但是这个问题是切实存在的。

- 规定两个库的serviceid不同，相同不可为主备
- 备库接到binlog并重放的过程中，生成与原binlog的serverid相同的binlog
- 每个库在收到自己主库发来的日志时，先判断serviceid，相同则丢弃

# 主备一致的高可用

## 主备延迟

主备切换一般是一个主机运维动作，比方说软件升级，主库所在机器按计划下线等，也可能是被动操作，比方说主库所在机器掉电

### 同步延迟

1. 主库A执行一个事务，写入binlog，我们把这个时刻记为T1
2. 之后传给备库B，我们把备库B接受完这个binlog的时刻记为T2
3. 备库B执行完成这个事务，我们把这个时刻记为T3

即主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，即T3-T1

可以通过备库中执行show slave status命令，他的返回结果里会显示seconds_behind_master,用于表示当前备库延迟了多少秒

这个计算方式是在每个事务的binlog里面都有一个时间字段的值记录主库写入的时间，备库取出当前正在执行的事务的时间字段的值计算其差得到这个主备延迟的值

当然在网络正常的时候，T2-T1的值是非常小的，即网络正常的情况下，主备延迟的主要来源是备库接受完binlog和执行完这个事务之间的时间差。所以主库延迟的最直接的表现是，**备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢**

### 那么 为什么呢

1. 有些部署条件下，备库所在机器的性能要比主库所在的机器性能差
   1. 更新请求对IOPS的压力，在主库和备库上是无差别的，因此在备库（性能稍微差一点的时候）中，会设置为“非双1”的模式
   2. 更新过程中也会触发大量的读操作，所以当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了
2. 但是就算备库和主库相同了，还有可能会有延迟，那么就可能是备库的压力大导致的了
   1. 主库提供了写能力，那么备库可以提供一些都能力，或者执行一些分析语句，不能影响正常业务，所以只能在备库上跑。通常是由于主库直接影响业务，使用起来比较克制，忽视了备库上的压力控制。
   2. 可以使用一些手段来做相关处理
      1. 一主多从，除了备库外，可以多接几个从库，让从库分担读压力
      2. 通过binlog输出到外部系统，由外部系统提供统计类的查询能力。
3. 大事务
   1. 主库上必须等事务执行完成才会写入binlog，再传给备库，因此主库语句执行过长，那这个事务可能延迟很久
      1. 例如一次性使用delete删除大量的数据，这个时间很长，会有很大的主从差距时间。
   2. 大表DDL，建议使用gh-ost方案
4. 备库的并行复制能力

### 可靠性优先策略

1. 判断备库B现在的seconds_behind_master，如果小于某个值继续下一步，否则持续重试此步骤
2. 把主库A改成只读状态，readonly设置为true
3. 判断备库B的seconds_behind_master的值，直到变为0为止
4. 把备库B改成可读写状态，readonly设置为false
5. 业务请求切到备库B

### 可用性优先策略

如果强行把步骤45直接执行，B可以直接读写，因此系统没有不可用时间了

这个切换流程，暂时可称为可用性优先流程。这个可能会导致数据不一致

由于有一定的主备延迟，有些数据备库并没有成功更新到，如果此时再次更新，那么极有可能导致数据行不一致。

当然也有情况数据的可用性优先级更高，有些库记录的是操作日志，这个发生短暂的不一致不会引发业务问题，但是业务系统依赖写入逻辑，如果库不可写，会导致线上的业务操作无法进行。因此我们可以优先切换，事后用binlog补充数据

### 那么如果突然掉电了呢

假设一个场景，主备延迟30min，如果主库A掉电，HA系统切换B为主库，按照可靠性优先策略应该等待主备到5s的时候再进行切换，但现在的情况比刚刚更严重，并不是系统只读，不可写的问题了，而是系统处于完全不可用的状态，因为主库A掉电后，连接还没有切到备库B。

那如果直接切换到备库B，保持B只读呢。这样自然也是不行的，主备切换后，客户端看不到执行完成的事务，会认为由数据丢失。

虽然中转日志持续应用数据会逐渐恢复，但是一些业务也是无法接受这种情况的

