# MySQL的索引

## 常见模型

- 哈希表：用键值KV存储数据的结构，我们只要输入带查找的键K，就可以找对对应的V。用一个哈希函数把K换算成一个确定的位置，然后把value放在数组的这个位置。K换算后出现同一个值，会在对应位置拉出一张链表。**哈希这种结构适用于只有等值查询的场景**，一般用于内存引擎缓存等。

  ![0c62b601afda86fe5d0fe57346ace957](MySQL的索引.assets/0c62b601afda86fe5d0fe57346ace957.png)

- 有序数组：在等值查询和范围查询的场景中的性能非常优秀。如果数组按照递增的顺序保存，那么如果要查一条数据就能使用二分法快速得到，时间复杂度是O(log(N))，但是在需要更新数据的时候比较麻烦，往中间插入一条记录必须得挪动后面所有的记录，成本太高。因此**只适用静态存储引擎**。

  ![bfc907a92f99cadf5493cf0afac9ca49](MySQL的索引.assets/bfc907a92f99cadf5493cf0afac9ca49.png)

- 二叉搜索树：每个节点的左儿子小于父节点，父节点小于右儿子，这种查询方式其实类似于二分法，因此时间复杂度是O(log(N))。

  - 由于索引不止存在内存中，还写在磁盘上因此其实实际上不应用二叉树，如果使用二叉树，单独访问一个行可能需要树高(n)*每次使用的时间，这样会导致查询过慢。
  - 为了使查询尽量少的读磁盘，必须让查询过程访问尽量少的数据块，因此不使用二叉树，使用N叉树，N取决于数据块的大小。
  - 以InnoDB的一个整数字段索引为例，N差不多是1200，树高4的时候，就可以存储1200的立方即17亿了。考虑树根的数据块总是在内存中的，那么一个10亿行的表上的索引，查询一个值仅需访问3次磁盘。当然树的第二层很大几率也在内存中，那么磁盘访问次数更少了



## InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表成为索引组织表。又因为InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

索引分为两种类型

- 主键索引：叶子节点存储的是整行数据。在InnoDB里，主键索引也被称为聚簇索引
- 非主键索引：叶子节点是主键的值，InnoDB中，非主键索引也被称为二级索引

因此如果根据主键查询，只要搜索ID这棵B+树，如果根据普通索引查询方式，则需要先搜索普通索引树，得到ID为500，然后再到ID索引树搜索一次，这个叫做**回表**。基于非主键索引的查询需要多扫描一颗索引树，因此我们在应用中应该尽量使用主键查询。

### 索引的维护

为了维护索引有序性，在插入新值的时候必须要做必要的维护，如果新插入的值隶属于中间，那需要在中间插入一条新的记录，逻辑上挪动后面的数据，空出位置。如果后面的数据页已经满了，那么根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂**。这样会<u>导致性能受到影响</u>。除了性能外，页分裂操作还<u>影响页的利用率</u>。原本放在一页的数据，分到两个页中。整体空间利用率降低大约50%。当然有分裂就有合并，当相邻两个页由于删除了数据，利用率很低的时候，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

### 自增主键

自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及挪动其他记录，也不会触发叶子节点的分裂。

如果使用业务逻辑的字段做主键，往往不能保证有序插入，这样写数据成本相对较高。

由于每个非主键索引的叶子节点上都是主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占约20个字节，如果用整型只需要4个，长整型8个。显然主键长度越小，普通索引叶子节点越小，普通索引占用空间越小。

> PS:KV场景使用业务字段直接做主键也是适合的

### 覆盖索引

针对于查询普通索引的范围查询，如果查询结果是一个范围且查询的内容在普通索引中无法覆盖的话，会触发回表，由于范围内数据可能过多，因此回表的次数也可能更多。在普通索引中每查到一条符合要求的记录，就会去主键索引中回表查询具体内容，直至普通索引中没有对应记录为止。若普通索引中查到对应记录5条，则需要回表5次。

为了避免这种回表过程，可以使用覆盖索引，普通索引中存储的内容一般为对应的列和主键值，因此如果查询返回的只是主键的话，索引返回的内容覆盖了真实想要的内容，就不会触发回表。这就是**覆盖索引**。

覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用**覆盖索引**是一个常用的性能优化手段，可通过建立一个(字段A,字段B)的联合索引来优化之后可能会被频繁查询的内容，这样可以不用回表查整行记录，减少语句的执行时间。

当然，索引的维护是有代价的，所以在建立冗余索引来支持覆盖索引就需要权衡考虑了

#### 最左前缀原则

索引项是按照索引定义里面的字段顺序排序的。

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

因此在建立联合索引的时候，如何安排索引内的字段顺序很关键。

由于支持最左前缀，因此(a,b)索引能够实现的功能与(a)相似，不需要再次创建。

评估标准是索引的复用能力。如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是要被优先考虑采用的

但是如果既有联合查询，又有基于本身的查询，且如果查询条件中只有b的语句，是无法使用(a,b)的联合索引的，因此需要建立两个(a,b),(b)

##### 最左匹配原则需要注意的内容

1. mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配，如a=1 and b=2 and c>3 and d=4，如果建立（a,b,c,d）索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，abd的顺序可以任意变化。
2. =和in可以乱序，比如a=1 and b=2 and d=4，建立（a,b,d）就可以任意顺序，mysql的优化器会自动优化索引
3. 索引列不能参与计算，保持列<u>干净</u>
4. 尽量扩展索引，不要新建索引，例如本来有a的索引，现在要加（a，b），只需要修改原来的索引即可

#### 索引下推（5.6后）

针对多个where的情况，有一部分where在索引中包含了，一部分是在主表中，那么会优先匹配索引中有的字段，减少回表的次数

例如<u>where a=1 and b=2 and c=3,现有索引(a,c)，会优先匹配a=1然后使用c=3再次过滤，过滤的结果再回表查看b=2的行</u>

### 零零散散的小事

索引的重建：(为什么？：因为索引可能因为删除，或者页分裂等原因导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按照顺序插入，这样能够提供页面的利用率，索引能够更紧凑更省空间)

- 普通索引的重建：直接使用alter语句删除并重建索引即可
- 主键索引的重建：通过删除主键约束重建会导致整个表重建，可以使用alter table T engine-InnoDB进行重建

针对复合主键的索引相关细节

- 当主键是(a,b)的时候，索引c 就是(c,a,b)，索引(c,a)就是(c,a,b)