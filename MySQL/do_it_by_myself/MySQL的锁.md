# MySQL的锁

针对并发访问的时候，数据库需要合理的控制资源的访问规则。因此用到了锁

## 全局锁

对整个数据库实例加锁。

MySQL提供了一个加全局读锁的方法，命令为Flush tables with read lock(FTWRL)。该命令会使整个库处于只读状态。数据更新语句，数据定义语句和更新类事务的提交语句会被阻塞。

使用场景：做全局逻辑备份。

让整库都只读，会导致

- 如果再主库上备份，那么在备份期间都不能执行更新，业务基本停摆；
- 如果在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，导致主从数据延迟

如果不添加类似全局锁这样的机制，会导致在备份过程中的**数据时间**不一致，这会导致部分数据时间高于其他时间，例如我买了东西，付了钱，而付钱的库备份了而买东西的库备份的早了一些，没有备份到这条数据。那么如果备份恢复的话，会导致付了钱但是却没有购买记录。

**事务隔离**中有**可重复读**这个类型，在**可重复读**状态下，同一个事务查询到的数据从头到尾都是一致的。

因此可以在可重复读隔离级别下开启一个事务。

> 官方自带的逻辑备份工具是musqldump，当mysqldump使用参数-single-transaction的时候，导数据会启动一个事务确保拿到一致性视图，MVCC的支持下，数据可以正常更新，该方式仅对支持事务的引擎有效(MyISAM不支持，仅能使用FTWRL)

当然想要全库只读，也可以使用set global readonly = true的方式，但是不推荐这种方式：

- 有些系统中，readonly的值被用来做其他逻辑，比方说判断主备库。因此如果修改global变量影响面较大
- 异常处理机制上有差异。FTWRL命令后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库可以恢复为正常更新态。但是如果将整个库设置readonly后，客户端发生异常，数据库依旧保持readonly态，导致整个库长期不可写
- readonly对super无效

## 表级锁

### 表锁

lock tables 限制别的线程读写同时也限制本线程接下来的操作对象

```mysql
lock tables ... read/write
```

> PS:read和write锁类似Java中的读写锁，如果获取到了读锁，写操作会阻塞，如果获取了写锁，读写操作都会阻塞

在没有更细粒度的锁时，表锁是最常用的控制并发的方式

### 元数据锁（MDL，5.5后）

> M **DML** D **DDL**主要是解决这俩的冲突

MDL主要是修改结构的时候使用的锁为了<u>防止修改结构的时候别的线程正在查询或者添加数据</u>

MDL不需要显示使用，在访问一个表的时候会自动加上。他能保证读写的准确性。

当对于一个表做增删改查操作的时候，加MDL读锁，当对表结构进行变更操作的时候加MDL写锁

- 读锁之间不互斥，因此多个线程对一张表增删改查不会出现问题
- 读写锁之间，写锁之间是互斥的，用来保证表结构操作的安全性，所以，如果有两个线程同时要给同一张表添加字段，需要等待另一个执行完后才能执行。

*给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据*

事务中的MDL锁，在语句执行开始时申请，但是语句结束后不会马上释放，而是会等到整个事务提交后再释放。

那么如何安全的给表添加字段呢

- 首先解决长事务，事务不提交，一直霸占MDL锁。查询当前执行中的事务，kill掉或者暂停

但是如果是热点表的话，刚刚kill掉新的请求就来了，考虑到这种请求，其实在alter table中设定等待时间，在等待时间中能拿到MDL锁最好，没拿到也不会阻塞后面的业务语句。

> PS:MariaDB合并了AliSQL的功能,支持DDL的NOWAIT/WAIT n的语法

```mariadb
ALTER TABLE xx WAIT N add column ..
ALTER TABLE xx NOWAIT add column ..
```

> PS 5.6后推出的onlineddl
>
> 1. 拿MDL写锁
> 2. DDL执行准备
> 3. 降级成MDL读锁
> 4. DDL核心执行（耗时长）
> 5. 升级成MDL写锁
> 6. DDL提交
> 7. 释放MDL锁

## 行锁