# MySQL的临时表

## 临时表和内存表

- 内存表，指的是使用Memory引擎的表，建表语法是create table ... engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。
- 临时表，可以使用各种引擎类型。如果使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。

## 临时表的特点

- 建表语句是create temporary table ..
- 一个临时表只能被创建它的session（一次会话，类似connection在open-close的生命周期内）访问，对其他线程不可见。
- 临时表可以与普通表同名
- 当session中有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。
- show tables命令不显示临时表。

临时表只能被创建它的session访问，所以在这个session结束的时候会自动删除这个临时表，因此适用于join优化这种场景，对于不同session临时表可以重名，如果多个session同时进行join优化，不需要担心表名重复导致建表失败的问题。不需要担心数据删除问题，不需要在客户端异常断开或者数据库异常重启后专门清理中间过程中生成的数据表。

> 此处需要考虑一个问题，对于程序中的连接池其实其链接不会被关闭，即如果创建会话级别的临时表，需要考虑这个会话可能会被重复使用的问题，可以考虑使用后手动清理，或者创建事务级别的临时表。

## 临时表在分库分表中的应用

由于不用担心线程之间的重名冲突，临时表常会被用在复杂查询的优化过程中。

一般情况下，分库分表系统都有一个中间层proxy，也有一些方案能直接链接数据库。如果大部分的语句都会包含某个字段的等值条件，那么就可以使用这个字段作为分区键。这样在proxy这一层解析完SQL语句后就能将这条语句路由到哪个分表做查询。

但是也会存在这种情况，查询条件中没有用到分区字段f，而且还有一个排序。这种情况下，有两种思路

- 在proxy层的进程代码中实现排序
  - 处理速度快，直接在内存中参与计算
  - 需要的开发工作量比较大，如果涉及join，group by这种操作，对中间层的开发能力要求比较高
  - 对proxy端的压力比较大，很容易出现内存不够用和CPU瓶颈的问题
- 把各个分库拿到的数据，汇总到一个MySQL实例一个表中，在这个汇总实例上做逻辑操作。一般会在汇总库中建立一个临时表
  - 在实践中其实每个分库的计算量都不饱和，所以会直接把临时表放到分库的某一个上

## 临时表重名

```mysql
mysql>create temporary table temp_t(id int primary key)engine=innodb;
```

这个语句执行的时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，找地方保存表数据下。

这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是‘#sql{进程id}\_{线程id}\_序列号’。可以使用select @@tmpdir命令，限制实例的临时文件目录。

对于这个表中数据存储方式，在不同的MySQL版本中有不同的处理方式

- 5.6之前，MySQL会在临时文件目录下创建一个相同前缀，以.ibd为后缀的文件，用来存放数据文件
- 5.7之后，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。

根据前缀规则，其实创建一个temp_t的InnoDB临时表，MySQL在存储上认为我们创建的表和普通表是不同的。

MySQL维护数据表，除了物理上有文件外，内存里也有一套机制区别不同的表，每个表都对应一个table_def_key

- 一个普通表的table_def_key的值是由‘库名+表名’得到的，所以如果要在一个库里创建两个同名的普通表，在创建第二个的时候就会发现table_def_key已经存在了
- 对于临时表， table_def_key在库名+表明的基础上又加上了"server_id+thread_id"

对于不同线程创建的临时表，磁盘文件名和table_def_key都是不同的，因此可以共存。

其实每个线程都维护了自己的临时表链表，这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，有的话就先有限操作临时表，没有的话操作普通表；在session结束的时候，对链表里的每个临时表，执行“DROP TEMPORARY TALBE + 表名”操作。

## 临时表和主备复制

```mysql
mysql>create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/
mysql>create temporary table temp_t like t_normal;/*Q2*/
mysql>insert into temp_t values(1,1);/*Q3*/
mysql>insert into t_normal select * from temp_t;/*Q4*/
```

这样的操作，如果关于临时表的操作都不记录，那么备库在执行Q4的时候，会找不到表temp_t从而中断主备同步，很明显这肯定是不可取的。

binlog设置为row的时候，记录的数据变更时记录的是这个操作的数据，因此产生的记录逻辑是插入了一行数据(1,1)，那么也是可以正常执行的，因此，在binlog_format=row的时候，不会写入和临时表相关的数据，在mixed和statement时候会记录临时表的操作。

> 在创建临时表的语句传入备库执行的时候，备库的同步线程会创建这个临时表，主库在线程退出的时候，会自动删除临时表，但是备库的同步线程是持续运行的，因此我们需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。（对于Java的线程池也可以考虑使用这种方式来处理临时表和链接复用的冲突问题）

> MySQL在记录binlog的时候，DDL语句create/alter table，都是原样记录的，连空格都不变，但是如果执行drop table命令就会被修改，会被修改为标准格式，后面加上 /\* generated by server \*/，因为主备删表的时候，可能会一起删除临时库和普通库，但是对于row下的是没有临时表日志的，这时候执行删除临时表命令就会报错，中止主备同步，因此drop table命令在记录binlog的时候，会对语句做改写。

> 主库上两个session创建了同名的临时表，那么这两个语句都会被传到备库上，但是备库的应用日志线程是共用的，对于这种看起来可能会报错的操作，MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中，备库应用线程就会知道执行每个语句主库线程id， 并利用这个线程id来构造临时表的table_def_key;*注意此处的serverId写入的是主库的server_id*

