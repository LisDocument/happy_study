# 唯一索引和普通索引

唯一索引和普通索引的选择依据（性能考虑）

例如参考执行查询<u>select id from T where k = 5</u>，该查询在索引树上查找的过程，先从B+数的树根开始，按层搜索到叶子节点，数据页中通过二分法定位记录。

- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录（考虑到MySQL的B+树排序）
- 对于唯一索引来说，索引定义了唯一性，查到到第一个满足条件的记录，就会停止继续检索

那么其实这个性能差距是**微乎其微的**

> PS:InnoDB的数据是按照数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认16K

因此当找到k=5的记录时，它所在的数据库就都在内存中了，那么多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。当然如果比较特殊的情况，比如k=5刚好是这个数据页的最后一个记录，那么要取下一个记录，就要去下一个数据页，比较复杂。但是这种情况比较少。对于整型字段，一个数据库可以存放近千个key，这种概率比较低，因此在计算平均性能差时，可以认为这个操作成本对于现在的CPU可以忽略不计

## change buffer

在更新一个数据页时，如果数据页在内存中就直接更新，而如果这个**数据页还没有在内存**中的话，在不影响数据一致性的前提下，InnoDB会将这些**更新操作缓存**在change buffer中，这样就不需要从磁盘中读入这个数据页了。在**下次查询需要访问这个数据页**的时候，将数据页读入内存，执行change buffer中这个页相关的操作。通过这个方式就能保证这个数据逻辑的正确性。

change buffer时可以持久化的数据，在内存中有拷贝，也会被写入到磁盘中。

将change buffer的操作应用到数据页，得到最新的结果的过程称为merge。除了访问数据页的时候会触发merge外，系统有后台线程会定期merge。数据库正常关闭过程中，也会执行merge操作。对于change buffer，能够减少读磁盘，语句执行速度会得到明显提升。并且数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高利用率。

- 但是对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。插入数据的时候，就必须要要判断表中是否存在对应值的记录。这必须要将数据读入内存才能判断了。如果已经读入了，那直接更新内存会更快，就没必要使用change buffer了。
- 普通索引正常可用

change buffer用的时buffer pool里的内存，无法无限增大。change buffer的大小，可以通过**innodb_change_buffer_max_size**来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%

倘若我们要更新一个记录的时候

- 这个记录要更新的目标页在内存中
  - 对于唯一索引来说，找到指定位置，**判断没有冲突**，插入这个值，语句执行结束
  - 对于普通索引来说，找到指定位置，插入这个值，语句执行结束
- 这个记录要更新的目标页不再内存中
  - 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束
  - 对于普通索引来说，将更新记录在change buffer，语句执行结束

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer减少了随机磁盘访问，对更新性能会有显著提升。

### 使用场景

因为merge是真正进行数据更新的时候，change buffer的主要目的是将记录的变更动作缓存下来，因此在数据页做merge之前，change buffer记录的变更越多，收益越大。

- 在写多读少的环境下，页面在写完以后马上被访问到的概率比较小，此时change buffer使用效果最好，常见为账单，日志类的系统，
- 在读多写少的环境下，写入后马上会做查询，那么即使满足条件，更新记录在change buffer，但是马上要访问，会立马触发merge。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。因此对于这种业务模式来说。反而起了副作用。

在实际使用中，普通索引和change buffer的配合使用，对数据量大的表更新优化还是比较明显的。

特别是在机械硬盘时。

### redolog和change buffer概念上的区分

在change buffer中记录下更新的方式，则为数据正常更新，计入redolog，事务完成。

WAL后读数据，不一定要读盘，也不一定要从redo log里面把数据更新以后才返回。虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果时正确的（脏读）

收益划分

- redolog主要节省的是随机写磁盘的IO消耗（转为顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗