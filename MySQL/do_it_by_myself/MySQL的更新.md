# MySQL的更新



```mysql
update T set c = c + 1 where ID = 2
```

- 分析器通过词法和语法解析知道这是一条更新语句
- 优化器决定要使用ID这个索引
- 执行器负责具体执行，找到这一行，然后更新

## 重要的日志模块

### redo log

- 概念：缓存和存储的关系，由于当前业务量较大，无法达成次次直接写入磁盘，即添加缓存区来做相关处理

  - 对于MySQL来说，更新一条记录需要在磁盘中找到对应的那条记录，然后更新，整个IO成本，查询成本很高，为了解决这个问题，MySQL的设计者采取了中间缓存的方式来处理，先写入对应的缓存中，然后再空闲时间中再完成磁盘的记录查询更新操作。而这个配合的整个过程，就是MySQL中提到的WAL(Write-Ahead Logging)，它的关键就是先写日志，再写磁盘

  - 当一条记录更新时，InnoDB会把记录先写到**redo log**里，并更新缓存，这个时候更新就算完成了，同时，InnoDB会在适当的时候将这个操作记录更新到磁盘里

  - InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小就是1G，那么这个这个缓存就可记录4G的操作，从头开始写，写到末尾又回到开头。write pos是当前记录的位置，一边写一边后移，当写完3的末尾后就到0的开头，check point是当前要擦除的位置，也是向后推移并且循环的，擦除记录前要把记录更新到对应数据文件。

    中间空着的位置，可以记录新的操作，如果write和check重叠了，表示缓冲区满了不能执行新的更新，得停下来擦除一部分数据，推进checkpoint。

    因此只有redo log在， InnoDB可以保证即使数据库发生异常初期，之前提交的记录都不会丢失，这个能力成为crash-safe。

![16a7950217b3f0f4ed02db5db59562a7](MySQL的更新.assets/16a7950217b3f0f4ed02db5db59562a7.png)

###  binlog

server层的日志

与redolog的不同

	- redolog是InnoDB特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用
	- redolog是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加上1”
	- redolog是循环写的，空间固定会用完；binlog是可追加写入的。即binlog文件写到一定大小后会切换下一个，不会覆盖
	- （自己）由于redolog记录向量不记录逻辑，因此速度应该是快于binlog的。

### 具体执行的内部流程

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行的数据页本来就在内存中，就直接返回给执行器，否则，先从磁盘中加载到内存，然后在返回
2. 执行器拿到数据，把这个值加上1，原来是N的话现在就是N+1，得到新的数据，再调用引擎接口写入新数据
3. 引擎将这行数据更新到内存中，同时这个更新到左记录到redo log中，这时候redo log处于prepare状态，然后告诉执行器执行完成了。随时可以提交
4. 执行器生成操作的binlog，并把binlog写入磁盘
5. 执行器调用提交事务接口，引擎把刚刚写入的redolog改成commit状态，更新完成

> *PS*:在redolog处于prepare阶段且binlog也正常写入的情况下crash，MySQL会自动COMMIT事务

![2e5bff4910ec189fe1ee6e2ecc7b4bbe](MySQL的更新.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

### 两阶段提交的必要性

为了让两份日志的逻辑一直，采取两阶段提交

binlog会记录所有的逻辑操作，并且是采用**追加写**的的方式。如果需要回复半个月内的记录，那么备份系统中一定会保存半个月的所有binlog，同时系统会定期做整库备份。当然这个定期取决于系统数据的重要性。可以一天一备也可以一周一备。

当想要执行恢复时

- 找到最近的一次全量备份
- 从全量备份的时间点开始，将备份的binlog依次取出，重放到指定恢复的时刻。

此时该库就和正常库一样了。

#### 两阶段提交的不同时刻，MySQL异常重启会出现什么现象

- 写入redolog处于prepare阶段之后，binlog写入前，发生崩溃，此时binlog没写，redolog没提交，因此崩溃恢复，事务会回滚，这时binlog还没写，所以数据也不会传到备库。
- binlog写完，redolog还没commit前发生crash，那么参照崩溃恢复的判断原则
  - 如果redolog里事务时完整的，也就是已经有了commit，就直接提交
  - 如果redolog事务只有完整的prepare，则判断事务binlog是否存在并完整
    - 是的话提交事务
    - 不是的话回滚

##### binlog是否完整

- statement的binlog最后会有COMMIT
- row的binlog，最后会有一个XID event

在5.6.2版本后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过检验checksum的结果来发现

binlog和redolog是通过XID关联的

##### 最后数据写入的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢

**redolog并没有记录数据页的完整数据，他并没有能力自己去更新磁盘数据，也不存在数据最终落盘是由redolog更新过去的情况**

1. 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页，最后数据落盘，就是把内存中的数据页写盘，这个过程，甚至与redolog毫无关系。
2. 在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redolog更新内存内容，更新完成后，内存页变成脏页，就回到了第一种情况的状态。

##### redo log buffer

在一个事务的更新过程中，日志是要写多次的，再插入数据的过程中，生成的日志得先保存起来，但又不能在还没commit的时候就写到redo log文件里，所以redo log buffer是一块内存，用来先存redo日志的，就是在执行第一句修改语句的时候，数据的内存就被修改了，redo log buffer也写入了日志，但是真正把日志写道redolog文件的是在执行commit语句的时候做的。

### 如果不使用两阶段提交会导致的部分的问题

因为redolog和binlog逻辑相互独立，如果不使用两阶段提交，那么两者就先后写。先后写会引起的问题

使用标题的update语句，假设当前ID=2的行，字段c值为0，在update语句写完第一个日志，第二个日志没写完发生crash

1. **先redo后bin**。假设redolog写完，binlog还没写完，MySQL重启。由于redolog写完后，系统即使崩溃，仍旧能够把数据恢复回来，因此恢复后c的值时1。但是由于binlog没写完就crash了，这个时候binlog没有记录这个语句，因此在之后备份日志的时候存储的binlog里面就没有这条语句，<u>那么如果以后使用binlog恢复库的时候，由于这个语句的binlog丢失，会导致恢复出来这一行的c值是0</u>，与源库值不同
2. **先bin后redo**。如果在binlog写完之后crash，由于redolog还没写，崩溃恢复后这个事务无效，所以这一行的c值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以之后用binlog恢复的时候多了一个事务出来，恢复的时候c就是1了，与源库不同

*所以：*redolog和binlog都可以表示事务的提交状态，而两阶段的提交就是让这两个状态保持逻辑上的一致，其实redolog本身属于缓存一系的数据，属于在MySQLcrash之后，直接恢复数据的。binlog属于操作日志，属于人为误删或者人为恢复库时人为恢复的保障。两者需要在一定程度上保持一致。如果在如上文一先一后，会导致无法相对控制一致，即MySQL**自动和手动恢复出现不一致**的问题

### 关于日志的配置问题

1. redo log用于保证crash-safe能力。**innodb_flush_log_at_trx_commit**这个参数设置为1的时候，表示每次事务的redo log都直接持久化到磁盘。(建议1)
2. **sync_binlog**设置为1的时候，表示每次事务的binlog都持久化到磁盘。（建议1）（配置中可配置两种模式：statement(记录sql语句)，row(记录行的内容，计两条，更前和更后)）

### 名词解释

1. 脏页：内存页和磁盘数据不一致导致了该内存页是脏页
2. 刷脏：将内存页数据刷到磁盘的操作就是刷脏

### 零零散散的小事

- 一个普通的select查询超过30ms，是MySQL刷脏导致的
  - 确认刷脏的场景
    - redolog写满，MySQL听器所有更新操作，刷脏
    - 系统内存不足，淘汰脏页，刷脏
    - 系统空闲时刷脏
  - 场景前两个会导致慢查的原因，redolog虽然可以循环写，但是在写满后页会停止更新操作进行刷脏的，意味着MySQL可能会因此阻塞一段时间。
  - InnoDB的刷脏策略
    - 全量（sharp checkpoint）：发生在关闭数据库时
    - 部分（fuzzy checkpoint）：发生在运行时
      - 定期刷脏
      - 最近最少使用刷脏
      - 异步/同步刷脏
      - 脏页过多刷脏
- 在执行一个update语句后，直接执行select语句，update语句未持久化，但是新的语句查询包括了之前的update语句。那时先将redolog写入磁盘还是直接都内容
  - 直接都内存
- 刷盘其实已经落库了，binlog和redolog都已经commit完成，当前记录已经全部到了redolog准备刷盘，此时如果宕机，redolog本身其实还是保有未落库的内容的。会加载到内存以及顺应刷脏场景，在场景触发后正常刷脏。