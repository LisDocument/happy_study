# 客户端的误解

## 1.如果库里面的表特别多，连接就会很慢

如果线上库包含表很多，这时候，客户端去链接的时候就可能会卡在下面这个界面上。

![image-20201212125408071](两个关于客户端的误解.assets/image-20201212125408071.png)

然而，如果这个db1库里表很少的话，链接就很快。



[MySQL的查询](../do_it_by_myself/MySQL的查询.md)中说明，每个客户端在和服务端建立链接的时候，需要做的事情就是tcp握手，用户校验，获取权限。这三个操作和库里多少表是无关的。

但是，在使用默认参数链接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在链接成功后，需要多做一些操作：

1. 执行 show databases；
2. 切到db1库，执行 show tables；
3. 把这两个命令的结果用于构建一个本地的hash表

所以如果在一个库的表个数非常多的时候，这一步就会花比较长的时间。

即，我们感知的链接过程慢，其实并不是连接慢，也不是服务端慢，是客户端慢。

如果在连接命令中加上-A，就可以关掉这个自动补全功能，然后客户端就可以快速返回。除了-A，也可以加--quick (-q)跳过这个阶段。

## 2.--quick是一个更容易引起误会的参数

这个参数虽然看起来像是个让服务端加速的参数，但是实际上恰恰相反，这个参数会降低服务端的性能。

MySQL客户端发送请求后，接受服务端返回结果的方法有两种：

1. 本地缓存，也就是在本地开一片内存，先把结果存起来。如果用API开发，对应的就是mysql_store_result方法。
2. 不缓存，读一个处理一个。如果用API开发，就是mysql_use_result方法。

MySQL客户端默认是第一种，如果加上--quick，就会使用第二种方式。采用不缓存的方式，如果本地处理得慢，就会导致服务端发送结果被阻塞，从而让服务变慢。至于其为何被称为quick。

1. 跳过表名自动补全功能。
2. mysql_store_result需要申请本地内存来缓存结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；
3. 不会吧执行命令记录到本地命令历史文件。

--quick，其实是让客户端变得更快。