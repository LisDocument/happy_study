# 为啥MySQL还能选错索引

## 环境复现

```mysql

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `b` (`b`)
) ENGINE=InnoDB；
```

数据插入

```mysql
delimiter ;;
create procedure idata()
begin 
	declare i int; 
	set i=1; 
	while(i<=100000)do 
		insert into t values(i, i, i); 
		set i=i+1; 
    end while;
end;;
delimiter ;
call idata();
```

如果插入执行过慢

可参考设置**innodb_flush_log_at_trx_commit**和**sync_binlog**设置为0

## 语句

当执行

```mysql
select * from t where a between 10000 and 20000
```

语句执行符合预期，explain中的key字段是a，表示优化器选择索引a

### 但是

当事务A开启后，事务B删除了数据并且再次调用存储过程插入了10w数据。

那么这时候数据就不会再选择索引a

```mysql
set long_query_time=0;/*将慢查询日志的阈值设置为0，表示当前线程所有语句都被录入慢查询日志中*/
select * from t where a between 10000 and 20000; /*Q1*/
select * from t force index(a) where a between 10000 and 20000;/*Q2*/
```

> ps：force index 可以强行指定选择哪个索引进行优化，例如代码中指定a进行处理

### 不得不说一下优化器的逻辑

优化器是用来选择索引，目的是为了获取一个最优的执行方案，用最小的代价执行语句。数据库中，**扫描行数是影响执行代价的因素之一**，行数越少，意味着访问磁盘数据的次数越少，CPU资源越少。

优化器还会结合**使用临时表，是否排序**等因素进行综合判断

### 那么怎么判断的扫描行数

MySQL的优化器是加载在执行器之前的，当时在真正开始执行语句前，其实是并不能精确知道满足这个条件的记录有多少条。只能根据**统计信息**来估算记录数。

这个**统计信息**就是**区分度**。一个索引上不同的值越多，这个索引的区分度越好。对于索引上不同值的个数，也叫做**基数（cardinality）**。基数越大，区分度越好

通过**show index**可以看到一个索引的基数。

但是得到基数的方法并不精准，如果希望精准的话代价太高了，只能**采样统计**

InnoDB会默认选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后*索引的页面数，得到了这个索引的基数。当变更的数据行数超过1/M的时候，会再次做一次索引统计。

MySQL中存在两种索引统计的方式，通过设置**innodb_stats_persistent**的值来选择

- on的时候，表示统计信息会持久化存储。默认N是20，M是10
- off的时候，表示统计信息只存储在内存中。默认N是8，M是16

当然这个基数计算得到肯定是不准的

### 当然扫描行数只是一部分的原因

> ps：rows这个字段表示预计扫描行数

普通索引和主键索引的问题也是在考虑范围中，使用普通索引需要考虑回表的代价，这个代价优化器页会考虑，因此预计扫描行数，只能做一部分的参考。当然可能执行的时候，普通索引仍旧优于主键索引。

如果在实践中，exlain的结果预估的rows值与现实情况差距较大，可以使用analyze命令解决rows的问题

```mysql
analyze table t
```

### 让我们看看排序的问题

```mysql
select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;
```

按照上述值，很明显对于索引a查询仅需要查询1000行记录，如果使用b，就要扫描最后50001个值，需要查询50001行记录。

然后结果是优化器选择b，hhh，你气不气

### 排序又是为啥呢

MySQL会根据词法解析的结果分析可能可以使用的索引作为候选项，然后依次判断每个索引需要扫描行数。如果有force index指定的索引在索引列表中，直接选择这个索引，不考虑其他索引的执行代价。

此处的优化器选择b，是它认为索引b可以避免排序（b本身就是索引，已经有序，选择选择b就不需要再做排序，虽然扫描行数多，也判定为代价更小）

## 索引选择异常处理

- 使用force index强行选择一个索引
  - 缺点：不优美，索引改了名字，语句也得改，变更的及时性不高，在开发的时候一般选择索引的情况还是比较少出现，等到线上出现问题的时候，才回去修改SQL语句，加上force index，然后再测试和发布，对于生产系系统，过程远不够敏捷
- 修改语句，引导MySQL使用我们期望的索引，对于排序的问题中，可以把order by b 换成order by b，a语义逻辑几乎相近，证明两个索引都需要排序，是等价的，因此扫描行数称为决策条件，优化器自然会选择比较少的索引a，但是这个适用场景较少，<u>此处由于有limit 1，因此加a和不加a其实是等价的，逻辑上没有区别</u>。
  - 使用limit 大额数据让优化器意识到b索引代价比较高。
- 新建一个更合适的索引，提供优化器选择，删除无用的索引