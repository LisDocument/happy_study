# 查这么多数据，会不会把数据库内存打爆

## 全表扫描对server层的影响

如果要对一个200G的InnoDB表db1.t，执行一个全表扫描。如果要把扫描结果保存在客户端，可以使用类似命令。

```mysql
mysql -h$host -P$port -u$user -p$pwd -e "select * from db1.t" > $target_file
```

InnoDB的数据时保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行可以直接放到结果集里面，然后返回客户端。

服务端并不需要一个完整的结果集。取发数据的流程是这样的：

1. 获取一行，写到net_buffer中。这块内存的大小是由参数**net_buffer_length**定义的，默认是16k。
2. 重复获取行，知道net_buffer写满，调用网络接口发出去。
3. 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。
4. 如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈(socket send buffer)写满了，进入等待。知道网络栈重新可写，再继续发送。

由此可以观察到

- 一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到所有数据大大小。
- socket send buffer也不可能达到200G（默认定义 /proc/sys/net/core/wmem_default），如果socker send buffer被写满，就会暂停读数据的流程

即 **MySQL是<u>边读边发</u>的**，如果客户端接受得慢，就会导致MySQL服务端由于结果发不出去这个事务执行时间变长。

使用show processlist可以观察State的值，如果客户端不去读socket receive buffer中的内容，那么State的值会一致处于“<u>Sending to client</u>”。

在[两个关于客户端的误解](两个关于客户端的误解.md)中提到如果客户端使用--quick参数，会使用mysql_use_result方法，这个方法是读一行处理一行，假如一个业务的逻辑比较复杂，每读一行的数据以后要处理的逻辑如果和慢，就会导致客户端要过很久才会去取下一行数据，也有可能发生这个<u>Sending to client</u>的状态。

因此，**对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，可以尽量使用mysql_store_result这个接口，直接把查询结果保存到本地内存**。

> 如果发现很多线程都处于Sending to client 这个状态，那么要考虑业务开发同学优化查询结果了。当然如果要快速减少这个状态的线程的话，将net_buffer_length设置为一个更大的值也是可以可选方案。

还有一种状态是“<u>Sending data</u>”。

- MySQL查询语句进入执行阶段后。首先把状态设置成“<u>Sending data</u>”
- 然后，发送执行结果的列相关的信息（meta data）给客户端
- 再继续执行语句的流程
- 执行完成后，把状态设置为空字符串

即，“<u>Sending data</u>”并不一定是指“正在发送数据”，而可能是出于执行器过程中的任意阶段。比如，构建一个锁等待的场景，就能看到<u>Sending data</u>状态（在MySQL8.0中显示的是excuting）

## 全变扫描对InnoDB的影响

在[MySQL的更新](../do_it_by_myself/MySQL的更新.md)中，介绍WAL机制时，讲述了InnoDB内存的一个作用，是保存更新的结果，再配合redo log，避免了随机写盘。

内存的数据页是在Buffer Pool（BP）中管理的，WAL里Buffer Pool起了加速更新的作用。但是实际上，他也可以加速查询。

> 当事务提交时，磁盘上的数据页是旧的，那么现在马上有一个查询来读这个数据页，是不是马上要把redolog应用到数据页呢。其实是不需要的，内存数据页的结果是最新的，直接读内存页就行了。这时候的查询不需要读磁盘，直接从内存那数据，速度很快。

Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：内存命中率。

在<u>show engine innodb status</u>结果中，可以查询一个系统当前的BP命中率（Buffer pool hit rate），一般一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。

InnoDB Buffer Pool的大小是由参数**innodb_buffer_pool_size**确定的，一般建议设置成可用物理内存的60%-80%。

### LRU算法

InnoDB内存管理用的是最近最少使用LRU算法。这个算法的核心就是淘汰最久未使用的数据。MySQL中的这个算法使用链表来实现的。

![image-20201212155600258]((查询)查询数据过多，内存怎么处理.assets/image-20201212155600258.png)

1. 在状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页。
2. 这时候有个读请求访问P3，由此变成状态2，P3被移动至最前面。
3. 状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是会清空链表末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。
4. 从效果上看，就是最久没被使用的数据页Pm被淘汰。

那么按照上述的算法扫描的话，就会把当前BP的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是BP里面主要放的是这个历史数据表的数据。这个对于一个正在做业务服务的库，会导致BP的内存命中率急剧下降，磁盘压力增加，SQL语句变慢。

因此，InnoDB不能直接用这个LRU算法。InnoDB对LRU算法做了改进。

### InnoDB改进的LRU算法

![image-20201212160255703]((查询)查询数据过多，内存怎么处理.assets/image-20201212160255703.png)

在InnoDB实现上，按照5：3的比例把整个LRU链表分成了young区和old区。图中LRU_old指向的就是old区域的第一个位置，即整个链表的5/8处，即靠近链表头部的5/8是young区域，尾部的3/8是old区域。

流程做了如下修改：

1. 状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。
2. 之后要访问一个新的不存在的于当前链表的数据页，依旧是淘汰数据页Pm，但是新插入的数据页Px，是放在LRU_old处。
3. 处于old区域的数据页，每次被访问的时候都要做下面这个判断
   1. 若这个数据页在LRU链表中存在时间超过了1s，就把他移动到链表头部；
   2. 若这个数据页在LRU链表中存在的时间短于1s，位置保持不变。1s这个时间，是由参数**innodb_old_blocks_time**控制的，其默认值是1000，单位是ms。

这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用了BP，但是对young区域完全没有影响，从而保证了BPO响应正常业务的查询命中率。

## 总结

当然，即便有各种操作优化全表扫描，但是全表扫描还是比较耗费IO资源的，所以业务高峰期还是不能在主库上执行全表扫描的。