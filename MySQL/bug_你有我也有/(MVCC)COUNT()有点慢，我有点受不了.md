# COUNT(*)这么慢，我有点啥办法呢

## COUNT(*)的实现方式

在不同的引擎中，COUNT(*)的实现方式不同

- MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）会直接返回这个数，效率很高
- InnoDB在执行count（*）的时候，需要把数据一行一行从引擎里读出来，然后累积基数

当然，如果是有过滤条件的count(*)，MyISAM旧没有这么快了

### 那为什么InnoDB不存总数呢

由于MVCC的原因，InnoDB表应该返回多少行也是不确定的。

InnoDB的默认隔离级别是可重复读。在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话（事务）可见，因此对于count(*)请求来说，InnoDB只好把数据一行行地读出依次判断，可见地行才能够用于计算**基于这个查询**的表的总行数

但是对于这样的MySQL，在执行count(*)操作的时候还是做了优化的

InnoDB是索引组织表，主键索引树的叶子节点是数据，普通索引树的叶子节点是主键值。因此普通索引比主键索引小很多，对于count(*)这种操作，遍历哪个索引树得到的结果逻辑都是一样的，因此MySQL优化器会找到最小的那棵树来遍历

**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**

使用show table status命令，发现命令输出结果里面也有一个TABLE_ROWS用于显示这个表多少行，但是这个命令不能代替count(*),TABLE_ROWS是采样估算的来的，有很大的误差

## 针对这些问题，我们来想想策略

### 用缓存系统统计计数（相对不好用）

使用Redis服务保存这个表的总行数，每插入一条数据Redis计数加1，删除减1。

但是缓存系统可能会丢失更新。

Redis数据不能永久的留在内存里，还是会找地方把这个值定期持久化存储起来，可是毕竟定期会有时延性。如果正好刚刚插入后Redis异常重启，那这个计算操作页会丢失。可以通过数据库单独执行一次count(*)获取真实的行数，再把这个值写入redis，次数比较少的全表扫描，还是可以接受的。

**将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑不精确的。**

可以参考事务的一致性问题进行理解，在一定意义上会导致数据不一致。

### 在数据库保存计数

可以使用MVCC从一定意义上支持缓存count

## 不同的COUNT

count是一个聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是null，累计值就加1，否则不加

因此count(*),count(pk),count(1)都表示返回满足条件的结果集的总行数；而count(字段)则表示返回满足条件的数据行里面，对应字段不为null的总个数。

- count(PK),InnoDB引擎会遍历整张表，把每一行的id都取出来，返回给server层，server层拿到id后判断是否为空，按行累加
- count(1)，InnoDB会遍历整张表，但不取值，server层对返回的每一行，放入个数字1，判断是不可能为空的，按行累加

对于这个来说，后者是快于前者的，因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。

对于count(字段)来说

1. 如果这个字段定义是not null的话，一行行读取这个字段，判断不能为null，按行累加
2. 如果这个字段定义是null的话，执行的时候，判断有可能是null，还要把值取出来再判断一下，不是null才累加

### 但是对count(*)不一样

这个不会把全部字段取出来，而是专门做了优化，不取值

count(字段)<count(主键 id)<count(1)≈count(*)