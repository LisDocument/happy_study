# 表数据删掉了，为啥表文件大小没变呢

MySQL8.0以前，表结构是存在以.frm为后缀的文件里。8.0以后，把表结构定义放在系统数据表中了

表数据既可以存在共享表空间，也可以是单独的文件。这个行为是由参数**innodb_file_per_table**控制的

- OFF表示表的数据放在系统共享表空间，也就是跟数据字典放在一起
- ON表示每个InnoDB表数据存在一个以.ibd为后缀的文件中

从MySQL5.6.6版本开始，他的默认值就是ON了

当不需要这个表的时候，通过drop table命令，系统会直接删除这个文件，但是如果放在共享表空间中，即使表删掉了，空间也是不会回收的

## 先来讲讲数据删除的流程

在索引中已经提到，InnoDB的数据都是用B+树的结构组织的

假如我们要删除一个记录，InnoDB只会把这个记录标记为删除，如果之后插入一个ID在这条记录前后的位置时，可能会复用这个位置，但是磁盘文件的大小并不会缩小。

对于InnoDB数据是按页存储的，那如果我们删掉了一个数据页上的所有记录，那整个数据页就可以被复用了。

但是数据页的复用和记录的复用是不同的

- 记录的复用，只限于符合范围条件的数据，只能在上条记录和下条记录的id范围之间
- 页的复用（在页的所有纪录被删除后，页会被标记为可复用），如果这时候插入任意一条记录需要使用新页时，该页可复用

如果相邻的两个数据页利用率都很小，系统就会将页的数据合并，同时另一个数据页标记为可复用。

因此如果使用delete命令将整个表的数据删除，所有的数据页都会被标记为可复用。但是磁盘上文件不会变小。

delete命令只是把记录的位置，或者数据页标记为了可复用，但是磁盘大小时不会变的，这些可以复用，而没被使用的空间，看起来就像是空洞

## 其实不止删除会导致空洞，插入也会

如果数据时按照索引递增顺序插入的，那么索引时紧凑的。但是如果数据是随机插入的，就可能导致索引的数据页分裂

可以看到由于A满了，再插入一个550的数据时，不得不申请一个新的页面来保存数据。页分裂完成后，pageA的末尾就留下了空洞（实际上可能不止1个记录的位置是空洞）。

![8083f05a4a4c0372833a6e01d5a8e6ea]((锁)(事务隔离)MySQL删除数据但是表文件大小没变啥情况.assets/8083f05a4a4c0372833a6e01d5a8e6ea.png)

另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。这也会造成空洞。那么需要使用一些方式来去掉空洞，达到收缩表空间的目的。

## 怎么收缩表空洞

### 重建表

原理：新建一个与表A结构相同的表B，然后按照主键递增的顺序，将数据一行行的从表A读出来再插入表B中，由于B是新建的表，所以表A的索引上的空洞，在B中旧不存在了，且B的主键索引更紧凑，数据页利用率页更高。即把B作为临时表，数据从A导入B的操作完成，用B代替A，从而实现收缩表A的作用

```mysql
alter table A engine=InnoDB
```

该命令等同于刚刚原理中说明的步骤。

但是花时间最多的步骤就是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入A的话，就会导致数据丢失，因此整个DDL中，表A不能有更新，也就是说这个DDL不是Online的

在5.6后引入Online DDL，对操作流程做了优化

- 建立一个临时文件，扫描A主键的所有数据页
- 用A的数据生成B+树，存储到临时文件
- 生成临时文件的过程中，将所有对A的操作记录在一个日志文件row log中
- 临时文件生成后，将日志文件中的操作应用的临时文件，得到一个逻辑数据上与A相同的数据文件
- 用临时文件替换A的数据文件

![2d1cfbbeb013b851a56390d38b5321f0]((锁)(事务隔离)MySQL删除数据但是表文件大小没变啥情况.assets/2d1cfbbeb013b851a56390d38b5321f0.png)

与非Online的不同之处在于日志文件记录和重放操作这个功能的存在，所以在重建表的时候，允许对表做增删改操作。

### Online DDL和MDL的问题

alter在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前旧退化成读锁了。

- 为什么要退化呢
  - 为了实现Online，MDL读锁不阻塞增删改操作
- 为什么不干脆解锁呢
  - 为了保护自己，禁止其他线程对这个表同时做DDL

这个操作是很消耗IO和CPU资源的，如果是线上服务，需要很小心的控制操作时间，如果想要比较安全的操作，可以使用Github中gh-ost来做

### Online和inplace

在**非Online**操作的时候，导出来存放的位置是tmp_table。这是个临时表是在server层创建的

**Online**操作的时候，重建出来的数据是放在tmp_file里的，这个临时文件是InnoDB在内部创建出来的，整个DDL过程都在InnoDB内部完成，对于server层来说，是个原地操作，这就是**inplace**名称的来源

```mysql
# 默认宝贝方式
alter table t engine=innodb,ALGORITHM=inplace;

# 拷贝表的方式，类似非Online
alter table t engine=innodb,ALGORITHM=copy;
```

但是inplace不等于Online，只是概念上在这里有一定意义上的重合。

inplace > Online的关系，对于8.0后添加全文索引FULLTEXT index 和 SPATIAL index就是inplace的但是非Online

