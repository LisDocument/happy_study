# 为什么SQL语句逻辑相同，性能却大相径庭

## 条件字段函数操作

### 日期比对的函数问题

对某个日期创建了一个索引，但是我只想要7月份的数据，包括历年来的7月份等，一般的逻辑会写下如下sql

```mysql
mysql> select count(*) from tradelog where month(t_modified)=7;
```

虽然t_modified有对应索引，但是查询后发现，这个语句依旧很慢

但是为什么t_modified='2018-7-1'就可以使用索引，而where month(t_modified)=7就不行呢

![3e30d9a5e67f711f5af2e2599e800286](where的条件很关键.assets/3e30d9a5e67f711f5af2e2599e800286.png)

对于SQL语句执行的执行，如果是2018-7-1就会追寻上图中的箭头去查询数据，而如果使用month函数的话，在传入7的时候，在树的根节点就无法进行下去了。

因此**对于索引字段做函数操作，可能会破坏索引值的有序性，因此优化器会决定放弃走树搜索功能**

但是，虽然优化器不走树搜索，但是优化器依旧可以选择遍历主键索引，也可以选择遍历t_modified，优化器比对索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引来的更快。因此会选择索引t_modified

因此会出现，使用t_modified索引和全索引扫描的情况，如果换成另一种写法，就能按照我们预期使用到索引的快速定位能力了

```mysql
mysql> select count(*) from tradelog where
    -> (t_modified >= '2016-7-1' and t_modified<'2016-8-1') or
    -> (t_modified >= '2017-7-1' and t_modified<'2017-8-1') or 
    -> (t_modified >= '2018-7-1' and t_modified<'2018-8-1');
```

> ps:针对上文的由于破坏索引的有序性，因此放弃树搜索功能，虽然是主要原因，但是也有优化器的**偷懒**行为存在，对于where id + 1 = 10000 这个SQL语句，加1操作并不会改变有序性，但是优化器还是不能快速定位到9999这一行，因此在写SQL语句的时候尽量保证不要对字段进行运算

## 隐式类型转换

对于MySQL为了方便程序员使用，添加了部分隐式类型转换的功能，这有可能导致我们的查询无法正确的使用索引

比方说，where varchar = int的时候其实是等于 where CAST（varchar as signed int） = int

那么这样的操作就会触发我们上面说的规则，优化器放弃走树搜索功能

### 隐式字符编码转换

在两张表中，如果两表存在编码不同的问题，例如u8和u8mb4,也会导致隐式转换

where CONVERT(u8 USING u8mb4) = u8mb4

> ps:由于u8mb4是u8的超集，根据编码习惯，自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也是**按照数据长度增加的方向**进行转换的

当然如果是where u8mb4 = u8的时候，自动转换的是等于后面的u8编码的数据，不会对原列有函数变化，因此能够正常走索引

ps:驱动表和被驱动表的概念->驱动表是主表，被驱动表是附表？

### 对于超字段长度的where

定义个字段varchar(10) t, 执行where t = '1234567890abcd'很明显t后面的值长度已经大于10了，理论上肯定不可能等于长度仅有10的t，因此返回肯定是空的，但是这里引擎还是会去查询，因为引擎中这个行只定义了长度是10，所以只截了10个字节，即'1234567890'去匹配，因此如果t没有索引的话，还会使用全表扫描的